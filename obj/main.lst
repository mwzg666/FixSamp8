C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\obj\main.obj
COMPILER INVOKED BY: D:\KeilMDK\C251\BIN\C251.EXE main.c XSMALL OPTIMIZE(0,SPEED) BROWSE INCDIR(.\Ads1110;.\Flash;.\mcp4
                    -725;.\IIC;.\MwPro;.\Uart;.\Lcd;.\ModBus;.\Temperaturn) PRINT(.\obj\main.lst) OBJECT(.\obj\main.obj) 

stmt  level    source

    1          #include "main.h"
    2          #include "mcp4725.h"
    3          #include "Lcd.h"
    4          #include "LcdApp.h"
    5          #include "ModBus.h"
    6          #include "Temper.h"
    7          #include "FlowMeter.h"
    8          #include "ModBusDev.h"
    9          #include "ModBusHost.h"
   10          
   11          
   12          BYTE code VERSION = 100;  // V1.0.0
   13          
   14          BYTE xdata StrTmp[64] = {0};
   15          //BYTE xdata Valve[8] = {0};
   16          
   17          BYTE ChannelError[FLOW_METER_CNT] ={0};
   18          
   19          #define Log //((CSampDemoDlg *)theApp.m_pMainWnd)->AddLog
   20          
   21          #define PARAM_SIGN  0x3132
   22          SYS_PARAM xdata SysParam;
   23          RUN_STATUS xdata RunStatus;
   24          REM_REGADDR xdata RemRegAddr;
   25          
   26          float SimFlow = 35.0;
   27          
   28          u16 SendFlowTim = 0;
   29          BYTE SendFlowFlag = 0;
   30          
   31          u16 RemReadTim = 0;
   32          BYTE RemReadflag = 0;
   33          BYTE RemPageflag = 0;
   34          
   35          u16 LcdBusyTim = 0;
   36          BYTE LcdBusyFlag = 0;
   37          BYTE ChNum = 1;
   38          
   39          alt_u8 g_Output[OUT_IO_COUNT]      = {0,0,0,0,0};   // 上电蓝灯亮 // 
   40          alt_u8 g_OutStatus[OUT_IO_COUNT]   = {0,0,0,0,0};
   41          BYTE PageSwitch = 0;                                //远程控制界面选择
   42          BYTE StartRem[5] = {0,0,0,0,0};
   43          BYTE RemFlag[5] = {0,0,0,0,0};
   44          
   45          
   46          u16  Timer0Cnt = 0;
   47          
   48          BYTE g_Key_Confrom  = 0; 
   49          BYTE g_Key_Power  = 0; 
   50          BYTE g_Key_Input  = 0; 
   51          BYTE Input_Status = 0;
   52          
   53          WORD gRunTime = 0;
   54          
   55          void DebugMsg(char *msg)
   56          {
   57   1          BYTE len = (BYTE)strlen(msg);
   58   1          //Uart1Send((BYTE *)msg,len);
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 2   

   59   1      }
   60          
   61          void DebugInt(int msg)
   62          {
   63   1          memset(StrTmp,0,64);
   64   1          sprintf(StrTmp,"%x\r\n",msg);
   65   1          DebugMsg(StrTmp);
   66   1      }
   67          
   68          void DumpCmd(BYTE *dat, BYTE len)
   69          {
   70   1          BYTE i;
   71   1          memset(StrTmp,0,64);
   72   1          for (i=0;i<len;i++)
   73   1          {
   74   2              if (strlen(StrTmp) >= 60)
   75   2              {
   76   3                  break;
   77   3              }
   78   2              sprintf(&StrTmp[i*3], "%02X ", dat[i]);
   79   2          }
   80   1          sprintf(&StrTmp[i*3], "\r\n");
   81   1          DebugMsg(StrTmp);
   82   1      }
   83          
   84          
   85          void Error()
   86          {
   87   1          while(1)
   88   1          {
   89   2              RUN_LED(1);
   90   2              Delay(50);
   91   2              RUN_LED(0);
   92   2              Delay(50);
   93   2          }
   94   1          
   95   1      }
   96          
   97          
   98          void SysInit()
   99          {
  100   1          HIRCCR = 0x80;           // 启动内部高速IRC
  101   1          while(!(HIRCCR & 1));
  102   1          CLKSEL = 0;              
  103   1      }
  104          
  105          void IoInit()
  106          {
  107   1          EAXFR = 1;
  108   1          WTST = 0;   //设置程序指令延时参数，赋值为0可将CPU执行指令的速度设置为最快
  109   1      
  110   1          P0M1 = 0x00;   P0M0 |= (1<<4) ;                     // P0.0 P0.1 P0.4 推挽输出
  111   1          P1M1 = (1<<4)|(1<<3);   P1M0 = 0x00;                       //设置为准双向口
  112   1          P2M1 = 0x00;   P2M0 |= 0x00;                      // P2.2 推挽输出
  113   1          P3M1 = 0x00;   P3M0 |= (1<<2)|(1<<3)|(1<<4);        //设置为准双向口
  114   1          P4M1 = 0x00;   P4M0 = 0x00;                       //设置为准双向口
  115   1          P5M1 = 0x00;   P5M0 |= (1<<0) | (1<<2);             //设置为准双向口
  116   1          P6M1 = 0x00;   P6M0 |= (1<<7);     //设置为准双向口
  117   1          P7M1 = 0x00;   P7M0 = 0x00;                         //设置为准双向口
  118   1      }
  119          
  120          
  121          void SensorInit()
  122          {
  123   1          // P1.0 -- 下降缘中断
  124   1          P1IM0 = 0;
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 3   

  125   1          P1IM1 = 0;
  126   1      
  127   1          // 优先级2
  128   1          //PIN_IP  |= (1<<1);
  129   1          PINIPH |= (1<<1);
  130   1          //P1_IP  = 1; // |= (1<<1);
  131   1          //P1_IPH = 1; //|= (1<<1);
  132   1      
  133   1          // 允许中断
  134   1          P1INTE |= (1<<0) | (1<<1) | (1<<4) | (1<<5);
  135   1      }
  136          
  137          
  138          
  139          void Timer0Init()
  140          {
  141   1          AUXR = 0x00;    //Timer0 set as 12T, 16 bits timer auto-reload, 
  142   1          TH0 = (u8)(Timer0_Reload / 256);
  143   1          TL0 = (u8)(Timer0_Reload % 256);
  144   1          ET0 = 1;    //Timer0 interrupt enable
  145   1          TR0 = 1;    //Tiner0 run
  146   1          
  147   1          // 中断优先级3
  148   1          PT0  = 1;
  149   1          PT0H = 0;
  150   1      }
  151          
  152          // 10ms 中断一下
  153          void Timer0Int (void) interrupt 1
  154          {
  155   1          Timer0Cnt ++;
  156   1      }
  157          
  158          #if 0
               // 公用中断服务程序
               void CommInt (void) interrupt 13
               {
                   u8 intf =  P1INTF;
                   
                   if (intf)
                   {
                       P1INTF = 0;
               
                       if (intf & (1<<0))  // P1.0 中断
                       {
                           Counter[0] ++;
                       }
               
                       if (intf & (1<<1))  // P1.1 中断
                       {
                           Counter[1] ++;
                       }
               
                       if (intf & (1<<4))  // P1.4 中断
                       {
                           Counter[2] ++;
                       }
               
                       if (intf & (1<<5))  // P1.5 中断
                       {
                           Counter[3] ++;
                       }
                   }
                   
               }
               #endif
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 4   

  191          
  192          
  193          void OutCtl(alt_u8 id, alt_u8 st)
  194          {
  195   1          if (g_OutStatus[id] == st)
  196   1          {
  197   2              return;
  198   2          }
  199   1      
  200   1          g_OutStatus[id] = st;
  201   1          
  202   1          switch(id)
  203   1          {   
  204   2              case LIGHT_YELLOW: 
  205   2              {
  206   3                  (st)? YEL_LIGHT(1):YEL_LIGHT(0);
  207   3                  break;
  208   3              }
  209   2      
  210   2              case LIGHT_BLUE: 
  211   2              {
  212   3                  (st)? BLU_LIGHT(1)   :BLU_LIGHT(0); 
  213   3                  break;
  214   3              }
  215   2              
  216   2              case GAS_BUMP:      //泵
  217   2              {
  218   3                  (st)? BUMP_M(1) : BUMP_M(0);
  219   3                  break;
  220   3              }
  221   2      
  222   2              case EX_FAN:        //风扇
  223   2              {
  224   3                  (st)? FANS_M(1) : FANS_M(0);
  225   3                  break;
  226   3              }
  227   2      
  228   2              case ALARM_SOUND:   //报警
  229   2              {
  230   3                  (st)? ALARM(1) : ALARM(0);       
  231   3                  break;
  232   3              }
  233   2          }
  234   1      
  235   1          
  236   1      }
  237          
  238          void OutFlash(alt_u8 id)
  239          {
  240   1          static alt_u16 OutTimer[OUT_IO_COUNT] = {0,0,0,0,0};
  241   1          if (OutTimer[id] ++ > LED_FLASH_TIME/10)
  242   1          {
  243   2              OutTimer[id] = 0;
  244   2              if (g_OutStatus[id] == 1)
  245   2              {
  246   3                  OutCtl(id, 0);
  247   3              }
  248   2              else
  249   2              {
  250   3                  OutCtl(id, 1);
  251   3              }
  252   2          }
  253   1      }
  254          
  255          void IoCtlTask()
  256          {
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 5   

  257   1          alt_u8 i;
  258   1          for (i=0;i<OUT_IO_COUNT;i++)
  259   1          {
  260   2              if (g_Output[i] == 2)
  261   2              {
  262   3                  OutFlash(i);
  263   3              }
  264   2              else
  265   2              {
  266   3                  OutCtl(i, g_Output[i]);
  267   3              }
  268   2          }
  269   1      }
  270          
  271          // 板载指示灯
  272          void RunLed(u16 dt)
  273          {   
  274   1          static u16 tm = 0;
  275   1          u16 to = 3000;
  276   1          tm += dt;
  277   1      
  278   1          if (tm > to)
  279   1          {
  280   2              tm = 0;
  281   2              RUN_LED(0);
  282   2          }
  283   1          else if (tm > (to-100))
  284   1          {
  285   2              RUN_LED(1);
  286   2          }
  287   1      }
  288          
  289          
  290          
  291          void Task1s()
  292          {
  293   1          static BYTE tm = 0;
  294   1      
  295   1          CLR_WDT = 1;  // 喂狗
  296   1          
  297   1          tm++;
  298   1          if(tm == 10)
  299   1          {
  300   2              ADC_Temp();
  301   2              //RemPageCtl();
  302   2              SyncModBusDev();
  303   2              tm = 0;
  304   2          } 
  305   1          
  306   1          if((tm == 6)||(tm == 3))
  307   1          {
  308   2              GetRetCode();
  309   2          }
  310   1          
  311   1          if(tm == 9)
  312   1          {
  313   2              if (RunStatus.Running)
  314   2              {  
  315   3                  DevRun();
  316   3              }
  317   2          }
  318   1      }
  319          
  320          
  321          void TimerTask()
  322          {
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 6   

  323   1          u16 delta = 0;
  324   1          static u16 Time1s = 0;
  325   1          
  326   1          if (Timer0Cnt)
  327   1          {
  328   2              delta = Timer0Cnt * 10;
  329   2              Timer0Cnt = 0;
  330   2      
  331   2              if (RX2_Cnt > 0)
  332   2              {
  333   3                  Rx2_Timer += delta;
  334   3              }
  335   2      
  336   2              if(RX3_Cnt > 0)
  337   2              {
  338   3                  Rx3_Timer += delta;
  339   3              }
  340   2              
  341   2              if(RX4_Cnt > 0)
  342   2              {
  343   3                  Rx4_Timer += delta;
  344   3              }
  345   2              
  346   2              SendFlowTim += delta;
  347   2              if(SendFlowTim > 220)
  348   2              {
  349   3                  SendFlowTim = 0;
  350   3                  SendFlowFlag = 1;
  351   3              }
  352   2      
  353   2              RemReadTim += delta;
  354   2              if(RemReadTim > 250)
  355   2              {
  356   3                  RemReadTim = 0;
  357   3                  RemReadflag = 1;
  358   3              }
  359   2      
  360   2              if (gRunTime < 5000)
  361   2              {
  362   3                  gRunTime += delta;
  363   3              }
  364   2      
  365   2              //if (g_CommIdleTime < 300)
  366   2              //{
  367   2                  //g_CommIdleTime += delta;
  368   2              //}
  369   2      
  370   2              #ifdef IRDA_FUN
                       if (IrDAStart == 1)
                       {
                           IrDATimer += delta;
                       }
                       #endif
  376   2      
  377   2              Time1s += delta;
  378   2              if (Time1s >= 100)
  379   2              {
  380   3                  Time1s = 0;
  381   3                  Task1s();
  382   3              }
  383   2              //Error();
  384   2              RunLed(delta);
  385   2              IoCtlTask();
  386   2              GetValve();
  387   2              ShowRemCh();
  388   2          }
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 7   

  389   1      }
  390          
  391          
  392          
  393          void Delay(WORD ms)
  394          {
  395   1          WORD t = 1000;
  396   1          while(ms--)
  397   1          {
  398   2              for (t=0;t<1000;t++) ;
  399   2          }
  400   1      }
  401          
  402          
  403          WORD ParamCheck(BYTE *buf, WORD len)
  404          {
  405   1          WORD dwSum = 0;
  406   1          WORD i;
  407   1      
  408   1          for (i = 0; i < len; i++)
  409   1          {
  410   2              dwSum += buf[i];
  411   2          }
  412   1      
  413   1          return dwSum;
  414   1      }
  415          
  416          /*
  417          void DefSenParam()
  418          {
  419              BYTE i;
  420              for (i=0; i<SENSOR_COUNT; i++)
  421              {
  422                  SysParam.SenParam[i].LOW_REVISE_COE_A = 1;
  423                  SysParam.SenParam[i].LOW_REVISE_COE_B = 1;
  424                  SysParam.SenParam[i].LOW_REVISE_COE_C = 1;
  425          
  426                  SysParam.SenParam[i].HIG_REVISE_COE_A = 1;
  427                  SysParam.SenParam[i].HIG_REVISE_COE_B = 1;
  428                  SysParam.SenParam[i].HIG_REVISE_COE_C = 1;
  429          
  430                  SysParam.SenParam[i].SUPER_REVISE_COE_A = 1;
  431                  SysParam.SenParam[i].SUPER_REVISE_COE_B = 1;
  432                  SysParam.SenParam[i].SUPER_REVISE_COE_C = 1;
  433          
  434                  SysParam.SenParam[i].DET_THR_1 = 500;
  435                  SysParam.SenParam[i].DET_THR_2 = 150;
  436                  SysParam.SenParam[i].DET_THR_3 = 150;
  437          
  438                  SysParam.SenParam[i].DET_TIME = 1000;
  439                  SysParam.SenParam[i].HV_THR = 1000;
  440              }
  441          }
  442          */
  443          
  444          /*
  445          void DefSenAlarm()
  446          {
  447              BYTE i;
  448              for (i=0; i<SENSOR_COUNT; i++)
  449              {
  450                  SysParam.AlmParam[i].DOSE_RATE_ALARM_1 = 300;
  451                  SysParam.AlmParam[i].DOSE_RATE_ALARM_2 = 400;
  452                  SysParam.AlmParam[i].CUM_DOSE_RATE_ALARM_1 = 300;
  453                  SysParam.AlmParam[i].CUM_DOSE_RATE_ALARM_2 = 400;
  454                  SysParam.AlmParam[i].INVALID_ALRAM_1 = 8000;
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 8   

  455                  SysParam.AlmParam[i].INVALID_ALRAM_2 = 10000;
  456              }
  457          }
  458          */
  459          
  460          void ReadParam()
  461          {
  462   1          EEPROM_read(0, (BYTE *)&SysParam, sizeof(SYS_PARAM));
  463   1      
  464   1          #if 0
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(SYS_PARAM));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(HOST_SENSOR_PARAM));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(HOST_ALRAM_PARA));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(float));
                   DebugMsg((char *)StrTmp);
                   
                   //Rs485Send((BYTE *)&SysParam, sizeof(SYS_PARAM));
                   
                   
                   if (SysParam.Sign != PARAM_SIGN)
                   {
                       DebugMsg("Sign error. \r\n");
                   }
               
                   if (SysParam.Sum != ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2))
                   {
                       DebugMsg("Param Check error. \r\n");
                   }
                   #endif
  494   1      
  495   1         
  496   1          if ( (SysParam.Sign != PARAM_SIGN) ||
  497   1               (SysParam.Sum != ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2)) )
  498   1          {
  499   2              //SysParam.Sign = PARAM_SIGN;
  500   2              //SysParam.Address = 1;
  501   2              ParamDef();
  502   2              //DefSenParam();
  503   2              //DefSenAlarm();
  504   2              WriteParam();
  505   2      
  506   2              //DebugMsg("Def Param. \r\n");
  507   2          }
  508   1      }
  509          
  510          
  511          void WriteParam()
  512          {
  513   1          EA = 0;    
  514   1          
  515   1          EEPROM_SectorErase(0);
  516   1          EEPROM_SectorErase(512);
  517   1          SysParam.Sum = ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2);
  518   1          if (!EEPROM_write(0, (BYTE *)&SysParam, sizeof(SYS_PARAM)))
  519   1          {
  520   2              Error();
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 9   

  521   2          }
  522   1      
  523   1          EA = 1;     //打开总中断
  524   1      }
  525          
  526          BYTE GetInput()
  527          {
  528   1          // 当前只有一个开关机状态 P2.1
  529   1          static BYTE his = LOCK_BIT();
  530   1          BYTE st = POWER_LOCK();
  531   1      
  532   1          if (st != his)
  533   1          {
  534   2              Delay(50);
  535   2              if ( st == POWER_LOCK() )
  536   2              {
  537   3                  his = st;
  538   3                  return st;
  539   3              }
  540   2          }
  541   1      
  542   1          return 0xFF;
  543   1      }
  544          
  545          
  546          void PowerOff()
  547          {
  548   1          PW_MAIN(0);
  549   1      
  550   1          while(1)
  551   1          {
  552   2              ;
  553   2          }
  554   1      }
  555          
  556          void HndInput()
  557          {
  558   1          static bool em = false;
  559   1          if(STOP_M() == 0)
  560   1          {
  561   2              Delay(10);
  562   2              if (STOP_M() == 0)
  563   2              {
  564   3                  if (RunStatus.Running)
  565   3                  {
  566   4                      StopSamp(false);
  567   4                  }
  568   3              }
  569   2      
  570   2              if (em == false)
  571   2              {
  572   3                  em = true;
  573   3                  ShowEmStop(em);
  574   3              }
  575   2          }
  576   1          else
  577   1          {
  578   2              if (em)
  579   2              {
  580   3                  em = false;
  581   3                  ShowEmStop(em);
  582   3              }
  583   2          }
  584   1      }
  585          
  586          /*
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 10  

  587          void ReportInput()
  588          {
  589              BYTE PwOff = POWER_OFF;
  590              
  591              if (g_CommIdleTime > 200)
  592              {
  593                  if (g_Key_Confrom)
  594                  {
  595                      g_Key_Confrom = 0;
  596                      SendPcCmd(0, CMD_CERTAINKEY, NULL, 0);
  597                      return;
  598                  }
  599          
  600                  if (g_Key_Power)
  601                  {
  602                      g_Key_Power = 0;
  603                      SendPcCmd(0, CMD_POWER, &PwOff, 1);
  604                      return;
  605                  }
  606          
  607                  #if 0
  608                  if (g_Key_Input)
  609                  {
  610                      g_Key_Input = 0;
  611                      SendPcCmd(0, CMD_INPUT, &Input_Status, 1);
  612                  }
  613                  #endif
  614              }
  615          }
  616          */
  617          
  618          void LedInit()
  619          {
  620   1          // 初始状态都为0
  621   1          
  622   1          // 三色LED
  623   1          //GRE_LED(0);    // 绿
  624   1          //YEL_LED(0);    // 黄
  625   1          //RED_LED(0);    // 红
  626   1      
  627   1          // 指示灯
  628   1          //RED_LIGHT(0); // 红灯
  629   1          YEL_LIGHT(0);   // 黄灯
  630   1          BLU_LIGHT(0);   // 蓝灯
  631   1          CloseValve();   // 电磁阀
  632   1          BUMP_M(0);      // 泵
  633   1          FANS_M(0);      // 风扇
  634   1          ALARM(0);       // 报警音
  635   1      }
  636          
  637          
  638          void ParamDef()
  639          {
  640   1          BYTE i;
  641   1          
  642   1          SysParam.Sign     = PARAM_SIGN;
  643   1          SysParam.Address = 1;
  644   1          SysParam.BkLight = 50;
  645   1      
  646   1          SysParam.SampMode = MODE_TIME;
  647   1          SysParam.SampTime = 5;  
  648   1          SysParam.SampVol   = 2;
  649   1          SysParam.AlarmThres   = 10;
  650   1          for (i=0;i<CHANNLE_NUM;i++)
  651   1          {
  652   2              SysParam.SampFlow[i] = 35;
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 11  

  653   2              //SysParam.Valve[i] = 0;
  654   2          }
  655   1      
  656   1          SysParam.Enable = 0x1F;
  657   1          SysParam.RemCtlFlag = false;
  658   1      
  659   1          RemRegAddr.SypAddr = MODBUS_PARAM_ADD;
  660   1          RemRegAddr.StuAddr = MODBUS_STATUS_ADD;
  661   1          RemRegAddr.InfoAddr = MODBUS_INFO_ADD;
  662   1      }
  663          
  664          void SaveParam()
  665          {
  666   1          //CString t;
  667   1          //t.Format(_T("SaveParam: %02X\r\n"), SysParam.Enable);
  668   1          //Log(t);
  669   1          //DebugMsg("123");
  670   1          WriteParam();
  671   1      }
  672          
  673          
  674          void UpdataUI()
  675          {
  676   1          BYTE i;
  677   1          for (i=0;i<CHANNLE_NUM;i++)
  678   1          {
  679   2              ChannelAlarm[i] = ((SysParam.Enable & (1<<i)) == 0)?0:1;
  680   2          }
  681   1          ShowStatus();
  682   1          Delay(200);
  683   1          StatusColor(true);
  684   1      }
  685          
  686          void InitLcd()
  687          {   
  688   1          memset(&RunStatus, 0, sizeof(RUN_STATUS));
  689   1          memset(&RunInfo, 0, sizeof(RUN_INFO));
  690   1          memset(&RealFlow, 0, sizeof(RealFlow));
  691   1          
  692   1          //ParamDef();
  693   1          ModeHint();
  694   1          Delay(200);
  695   1          HideModule(MP_HINT_END);
  696   1          Delay(200);
  697   1          UpdataUI();    
  698   1          Delay(200);
  699   1          SendParam();
  700   1          Delay(200);
  701   1          SetBkLight(false);
  702   1          Delay(200);
  703   1          ShowDevInfo();
  704   1          Delay(200);
  705   1      }
  706          
  707          
  708          void GetFlow()
  709          {
  710   1          BYTE i;
  711   1          WORD  w;
  712   1          DWORD d;
  713   1      
  714   1          
  715   1          for (i=0;i<CHANNLE_NUM;i++)
  716   1          {
  717   2              if (SysParam.Enable & (1<<i))
  718   2              {
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 12  

  719   3                  RunStatus.Flow[i] = RealFlow[i].val;  // 模拟 -- 实际要从流量计中读取
  720   3                  w = (WORD)(RunStatus.Flow[i]*10);
  721   3                  RunInfo.ChFlow[i].Flow = SwWord(w);
  722   3                  
  723   3                  RunStatus.Volume[i] =  RealFlow[i].Totol; 
  724   3                  w = (WORD)(RunStatus.Volume[i]*10);
  725   3                  RunInfo.ChFlow[i].Vol = SwWord(w);
  726   3              }
  727   2          }
  728   1      
  729   1          // 总流量
  730   1          RunStatus.TotleFlow = RealFlow[8].val;
  731   1          d = (DWORD)(RealFlow[8].val*10);
  732   1          RunInfo.TotFlow.Flow = SwDWord(d);
  733   1      
  734   1          // 总体积
  735   1          RunStatus.TotleVol = RealFlow[8].Totol;
  736   1          d = (DWORD)(RealFlow[8].Totol*10);
  737   1          RunInfo.TotFlow.Vol   = SwDWord(d);
  738   1      }
  739          
  740          void StartSamp()
  741          {
  742   1          memset(&RunStatus, 0, sizeof(RUN_STATUS));
  743   1          memset(&RunInfo, 0, sizeof(RUN_INFO));
  744   1          memset(&RealFlow, 0, sizeof(RealFlow));
  745   1          
  746   1          RunStatus.Running = true;
  747   1          g_Output[LIGHT_BLUE] = 1;
  748   1          CheckValve();
  749   1          OpenPump();
  750   1          SetStartBtn(0);
  751   1      
  752   1      }
  753          
  754          void StopSamp(bool Auto)
  755          {
  756   1          ClosePump();
  757   1          memset(RealFlow,0, sizeof(RealFlow));
  758   1      
  759   1          RunStatus.Running = false;
  760   1          g_Output[LIGHT_BLUE] = 0;
  761   1          
  762   1          SetStartBtn(1);  // 按钮自动变为“开始”
  763   1          
  764   1          if (Auto)  // 自动结束
  765   1          {
  766   2              // 显示取样结束提示框
  767   2              ShowModule(MP_HINT_END, REG_HINT_END);
  768   2          }
  769   1      }
  770          
  771          // 定时模式
  772          void TimingMode()
  773          {
  774   1          if (RunStatus.RunTime >= ((DWORD)SysParam.SampTime) * 60)
  775   1          {
  776   2              StopSamp(true);
  777   2          }
  778   1      }
  779          
  780          
  781          // 定量模式
  782          void VolumeMode()
  783          {
  784   1          if (RunStatus.TotleVol >= SysParam.SampVol)
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 13  

  785   1          {
  786   2              StopSamp(true);
  787   2          }
  788   1      }
  789          
  790          
  791          void RunCheck()
  792          {
  793   1          switch (SysParam.SampMode)
  794   1          {
  795   2              case MODE_TIME:  TimingMode();  break;
  796   2              case MODE_VOL:   VolumeMode();  break;
  797   2          }
  798   1      }
  799          
  800          void AbnorAlaerm()
  801          {   
  802   1          BYTE i;
  803   1          bool HaveAlarm = false;
  804   1      
  805   1          
  806   1          
  807   1          for(i = 0;i < CHANNLE_NUM;i++)
  808   1          {
  809   2              if( (ChannelAlarm[i] == ALM_FLOW_ABNOR) ||
  810   2                  (ChannelAlarm[i] ==  ALM_FLOW_LOW) || 
  811   2                  (ChannelAlarm[i] == ALM_FLOW_HIGH)  )
  812   2              {
  813   3                  HaveAlarm = true;
  814   3                  break;
  815   3              }
  816   2          }
  817   1      
  818   1          if (HaveAlarm)
  819   1          {
  820   2              g_Output[LIGHT_YELLOW] = 1;
  821   2              g_Output[ALARM_SOUND] = 2;
  822   2          }
  823   1          else
  824   1          {
  825   2              g_Output[LIGHT_YELLOW] = 0;
  826   2              g_Output[ALARM_SOUND] = 0;
  827   2          }
  828   1      }
  829          void CheckAlarm()
  830          {
  831   1          BYTE i;
  832   1          float flow;
  833   1          
  834   1          for (i=0;i<CHANNLE_NUM;i++)
  835   1          {
  836   2              if (SysParam.Enable & (1<<i))
  837   2              {
  838   3                  flow = RunStatus.Flow[i];
  839   3                  if (flow > SysParam.SampFlow[i]*(100+SysParam.AlarmThres)/100)
  840   3                  {
  841   4                      ChannelAlarm[i] = ALM_FLOW_HIGH;
  842   4                  }
  843   3                  else if (flow < SysParam.SampFlow[i]*(100-SysParam.AlarmThres)/100)
  844   3                  {
  845   4                      ChannelAlarm[i] = ALM_FLOW_LOW;
  846   4                  }
  847   3                  else
  848   3                  {
  849   4                      ChannelAlarm[i] = ALM_FLOW_NOR;
  850   4                  }
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 14  

  851   3              }
  852   2              else
  853   2              {
  854   3                  ChannelAlarm[i] = ALM_CH_DISABLE;
  855   3              }
  856   2              
  857   2              if( (ChannelError[i] > 3) && (ChannelAlarm[i] != ALM_CH_DISABLE) )
  858   2              {
  859   3                  ChannelAlarm[i] = ALM_FLOW_ABNOR;
  860   3              }
  861   2          }
  862   1      
  863   1          if (memcmp(HisAlarm,ChannelAlarm,CHANNLE_NUM) != 0)
  864   1          {
  865   2              // 报警有变化才更新界面
  866   2              Delay(200);
  867   2              ShowStatus();
  868   2              Delay(200);
  869   2              AbnorAlaerm();
  870   2              StatusColor(false);
  871   2      
  872   2              memcpy(HisAlarm,ChannelAlarm,8);
  873   2          }
  874   1      }
  875          
  876          // 1秒运行一次
  877          void DevRun()
  878          {
  879   1          RunStatus.RunTime ++;
  880   1          
  881   1          // 1. 获取流量
  882   1          GetFlow();
  883   1      
  884   1          // 2. 显示流量和状态
  885   1          ShowFlow();
  886   1          //Delay(200);
  887   1          
  888   1          // 3. 检查报警状态  
  889   1          if (RunStatus.RunTime > 10)
  890   1          {
  891   2              // 运行时间大于10秒才检测
  892   2              CheckAlarm();
  893   2          }
  894   1          
  895   1          // 4. 根据模式判断是否结束取样
  896   1          RunCheck();
  897   1      }
  898          
  899          /*
  900          void MainTask()
  901          {
  902              
  903          }
  904          */
  905          
  906          void GetValve()
  907          {
  908   1          BYTE i;
  909   1          for(i = 0;i<CHANNLE_NUM;i++)
  910   1          {
  911   2              if(SysParam.Enable & (1<<i))
  912   2              {
  913   3                  RemChStatus[i] = 1;
  914   3                 //SysParam.Valve[i] = 1;
  915   3              }
  916   2              else
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 15  

  917   2              {
  918   3                  RemChStatus[i] = 0;
  919   3      //           SysParam.Valve[i] = 0;
  920   3              }
  921   2          }
  922   1          //CheckValve();
  923   1      }
  924          
  925          //开启或关闭通道电磁阀
  926          void CheckValve()
  927          {
  928   1          BYTE i;
  929   1          for(i = 0;i<CHANNLE_NUM;i++)
  930   1          {
  931   2              if(RemChStatus[i])//(SysParam.Valve[i])
  932   2              {
  933   3                  switch(i)
  934   3                  {
  935   4                      case 0 : VALVE0(1); break;
  936   4                      case 1 : VALVE1(1); break;
  937   4                      case 2 : VALVE2(1); break;
  938   4                      case 3 : VALVE3(1); break;
  939   4                      case 4 : VALVE4(1); break;
  940   4                      case 5 : VALVE5(1); break;
  941   4                      case 6 : VALVE6(1); break;
  942   4                      case 7 : VALVE7(1); break;  
  943   4                  }
  944   3              }
  945   2              else
  946   2              {
  947   3                  switch(i)
  948   3                  {
  949   4                      case 0 : VALVE0(0); break;
  950   4                      case 1 : VALVE1(0); break;
  951   4                      case 2 : VALVE2(0); break;
  952   4                      case 3 : VALVE3(0); break;
  953   4                      case 4 : VALVE4(0); break;
  954   4                      case 5 : VALVE5(0); break;
  955   4                      case 6 : VALVE6(0); break;
  956   4                      case 7 : VALVE7(0); break;  
  957   4                  }
  958   3              }
  959   2          }
  960   1          Delay(20);
  961   1      }
  962          
  963          void CloseValve()
  964          {
  965   1          VALVE0(0);
  966   1          VALVE1(0);
  967   1          VALVE2(0);
  968   1          VALVE3(0);
  969   1          VALVE4(0);
  970   1          VALVE5(0);
  971   1          VALVE6(0);
  972   1          VALVE7(0);
  973   1          Delay(20);
  974   1      
  975   1      }
  976          // 开启气泵
  977          void OpenPump()
  978          {
  979   1          //BUMP_M(1);
  980   1          g_Output[GAS_BUMP] = 1;
  981   1      }
  982          
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 16  

  983          
  984          // 停止气泵
  985          void ClosePump()
  986          {
  987   1          //BUMP_M(0);
  988   1          CloseValve();
  989   1          g_Output[GAS_BUMP] = 0;
  990   1      }
  991          
  992          void SendReadFlowCmd(BYTE ch)
  993          {
  994   1          ChannelError[ch-1] ++;
  995   1          SendReadFlow(ch);    
  996   1      }
  997          
  998          WORD GetAlarm(BYTE i)
  999          {
 1000   1          //BYTE i;
 1001   1      
 1002   1      //    for (i=0;i<8;i++)
 1003   1      //    {
 1004   1              if(ChannelAlarm[i] == ALM_CH_DISABLE)
 1005   1              {
 1006   2                  return ALM_CH_DISABLE;
 1007   2              }
 1008   1              if (ChannelAlarm[i] ==  ALM_FLOW_ABNOR)
 1009   1              {
 1010   2                  return ALM_FLOW_ABNOR;
 1011   2              }
 1012   1              
 1013   1              if (ChannelAlarm[i] ==  ALM_FLOW_HIGH)
 1014   1              {
 1015   2                  return ALM_FLOW_HIGH;
 1016   2              }
 1017   1      
 1018   1              if (ChannelAlarm[i] ==  ALM_FLOW_LOW)
 1019   1              {
 1020   2                  return ALM_FLOW_LOW;
 1021   2              }
 1022   1          //}
 1023   1      
 1024   1          return ALM_FLOW_NOR;
 1025   1      }
 1026          
 1027          void SyncModBusDev()
 1028          {
 1029   1          BYTE i;
 1030   1          memset(&ModBusParam, 0, sizeof(MODBUS_PARAM));
 1031   1          //ModBusParam.AlamrThres = SysParam.AlarmThres;
 1032   1          ModBusParam.ChEnable =   SysParam.Enable;
 1033   1      
 1034   1      //    for (i=0;i<8;i++)
 1035   1      //    {
 1036   1      //        ModBusParam.ChFlow[i] = (WORD)(SysParam.SampFlow[i]);
 1037   1      //        //ModBusParam.ChValve[i] = SysParam.Valve[i];
 1038   1      //    }
 1039   1      //    ModBusParam.SampFlow = SysParam.SampVol;
 1040   1      //    ModBusParam.SampMode = SysParam.SampMode;
 1041   1      //    ModBusParam.SampTime = SysParam.SampTime;
 1042   1      //    ModBusParam.SampVol = SysParam.SampVol;
 1043   1          ModBusParam.RemCtlFlag = SysParam.RemCtlFlag;
 1044   1          ModBusParam.Addr = RemRegAddr.SypAddr;
 1045   1          memset(&ModBusStatus, 0, sizeof(MODBUS_STATUS));
 1046   1      //    ModBusStatus.TotleTime = SysParam.TotleTime;
 1047   1      //    ModBusStatus.TotleVol = SysParam.TotleFlow;
 1048   1      
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 17  

 1049   1      //    ModBusStatus.SampleFlow = RunStatus.TotleFlow;
 1050   1      //    ModBusStatus.SampleVol = RunStatus.TotleVol;
 1051   1          for(i = 0;i < 8;i++)
 1052   1          {
 1053   2              ModBusStatus.Alarm[i] = GetAlarm(i);
 1054   2          }
 1055   1      
 1056   1      //    ModBusStatus.RemTime = ((DWORD)SysParam.SampTime) * 60 - RunStatus.RunTime;
 1057   1      //    ModBusStatus.RunTime = RunStatus.RunTime;
 1058   1          ModBusStatus.RunStatus = RunStatus.Running;
 1059   1          ModBusStatus.Addr = RemRegAddr.StuAddr;
 1060   1      //    for (i=0;i<8;i++)
 1061   1      //    {
 1062   1      //        ModBusStatus.ChFlow[i] = (WORD)(RunStatus.Flow[i]);
 1063   1      //        ModBusStatus.ChVol[i] = (WORD)(RunStatus.Volume[i]);
 1064   1      //    }
 1065   1      
 1066   1          memset(&ModBusInfo, 0, sizeof(MODBUS_INFO));
 1067   1          ModBusInfo.Address = SysParam.Address;
 1068   1          ModBusInfo.Version = VERSION;
 1069   1          ModBusInfo.Addr = RemRegAddr.InfoAddr;
 1070   1          
 1071   1      }
 1072          
 1073          BYTE SendRemCtlCmd(BYTE Addr, BYTE Cmd, WORD Reg, WORD Count, BYTE * Data)
 1074          {
 1075   1         
 1076   1          WORD i = 0;
 1077   1          WORD crc, SendLen;
 1078   1          //Error();
 1079   1          memset(&HostSendFrame, 0, sizeof(HOST_SEND_FRAME));
 1080   1          
 1081   1          HostSendFrame.Address = Addr; //Param.DevAddr;
 1082   1          HostSendFrame.FunctionCode = Cmd;
 1083   1          HostSendFrame.RegAddr = RegSw(Reg);
 1084   1          HostSendFrame.RegCount =  RegSw(Count);
 1085   1      
 1086   1          SendLen = 6;
 1087   1      
 1088   1          if (((Count*2) > 0) && (Data != NULL))
 1089   1          {
 1090   2              HostSendFrame.Data[0] = Count*2;  // 数据长度
 1091   2              SendLen ++;
 1092   2              i++;
 1093   2              memcpy(&HostSendFrame.Data[1], Data, Count*2);
 1094   2              SendLen += Count*2;
 1095   2              i+=2;
 1096   2          }
 1097   1          
 1098   1          // 计算CRC , 并添加到数据后面
 1099   1          crc = CRC16Calc((BYTE *)&HostSendFrame, SendLen);
 1100   1          //printf("crc = %x\r\n",crc);
 1101   1          HostSendFrame.Data[i]  = (BYTE)(crc);
 1102   1          HostSendFrame.Data[i+1] = (BYTE)(crc>>8);
 1103   1          
 1104   1          SendLen += 2; 
 1105   1          Uart4Send((BYTE *)&HostSendFrame, (BYTE)SendLen);
 1106   1      
 1107   1          return true;
 1108   1      }
 1109          
 1110          void FlowTask()
 1111          {
 1112   1          if (RunStatus.Running)
 1113   1          {
 1114   2              if(SendFlowFlag == 1)
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 18  

 1115   2              {
 1116   3                  SendFlowFlag = 0;
 1117   3                  SendReadFlowCmd(ChNum++);
 1118   3              }
 1119   2              
 1120   2              if (ChNum>9)
 1121   2              {
 1122   3                  ChNum = 1;
 1123   3              }
 1124   2          }
 1125   1      }
 1126          
 1127          //远程控制界面切换
 1128          void RemPageCtl()
 1129          {
 1130   1         //BYTE i = 0;
 1131   1      //   static BYTE StartRem[5] = {0};
 1132   1      //   static BYTE RemFlag[5] = {0};
 1133   1         //#if 0
 1134   1          switch(PageSwitch)
 1135   1          {
 1136   2              case 0:
 1137   2              {
 1138   3                  if(RunStatus.Running)
 1139   3                  {
 1140   4                      if(SysParam.RemCtlFlag)
 1141   4                      {
 1142   5                          if(!RemFlag[4])
 1143   5                          {
 1144   6                              RemFlag[4] = 1;
 1145   6                              StartRem[4]++;
 1146   6                              EnterPage(PAGE_REM);
 1147   6                             
 1148   6                          }
 1149   5                      }
 1150   4                      else
 1151   4                      {
 1152   5                          if(StartRem[4] != 0)
 1153   5                          {
 1154   6                              RemFlag[4]  = 0; 
 1155   6                              SendParam();
 1156   6                              ModeHint(); 
 1157   6                              CheckAlarm();
 1158   6      
 1159   6                              //UpdataUI();
 1160   6                              EnterPage(PAGE_MAIN);
 1161   6                              StartRem[4] = 0;
 1162   6                          }
 1163   5                      }
 1164   4                  }
 1165   3                  else
 1166   3                  {
 1167   4                       if(SysParam.RemCtlFlag)
 1168   4                      {
 1169   5                          if(!RemFlag[0])
 1170   5                          {
 1171   6                              RemFlag[0] = 1;
 1172   6                              StartRem[0]++;
 1173   6                              EnterPage(PAGE_REM);
 1174   6                             
 1175   6                          }
 1176   5                      }
 1177   4                      else
 1178   4                      {
 1179   5                          if(StartRem[0] != 0)
 1180   5                          {
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 19  

 1181   6                              RemFlag[0]  = 0; 
 1182   6                              SendParam();
 1183   6                              ModeHint(); 
 1184   6                              //UpdataUI();
 1185   6                              EnterPage(PAGE_START);
 1186   6                              StartRem[0] = 0;
 1187   6                          }
 1188   5                      }
 1189   4                      break;
 1190   4                  }
 1191   3              }
 1192   2              
 1193   2              case 1:
 1194   2              {
 1195   3                  if(SysParam.RemCtlFlag)
 1196   3                  {
 1197   4                       if(!RemFlag[1])
 1198   4                      {
 1199   5                          RemFlag[1] = 1;
 1200   5                          StartRem[1]++;
 1201   5                          EnterPage(PAGE_REM);
 1202   5                          
 1203   5                       }
 1204   4                  }
 1205   3                  else
 1206   3                  {
 1207   4                       if(StartRem[1] != 0)
 1208   4                      {
 1209   5                          
 1210   5                          RemFlag[1] = 0;
 1211   5                          if(RunStatus.Running)
 1212   5                          {
 1213   6                              SendParam();
 1214   6                              ModeHint(); 
 1215   6                              CheckAlarm();
 1216   6                              //UpdataUI();
 1217   6                              EnterPage(PAGE_MAIN);
 1218   6                          }
 1219   5                          else
 1220   5                          {
 1221   6                              SendParam();
 1222   6                              ModeHint(); 
 1223   6                              UpdataUI();
 1224   6                              EnterPage(PAGE_MAIN);
 1225   6                          }
 1226   5                          StartRem[1] = 0;
 1227   5                       }
 1228   4                  }
 1229   3                  break;
 1230   3              }
 1231   2              
 1232   2               case 2:
 1233   2              {
 1234   3                  if(SysParam.RemCtlFlag)
 1235   3                  {
 1236   4                       if(!RemFlag[2])
 1237   4                      {
 1238   5                          RemFlag[2] = 1;
 1239   5                          StartRem[2]++;
 1240   5                          EnterPage(PAGE_REM);
 1241   5                         
 1242   5                       }
 1243   4                  }
 1244   3                  else
 1245   3                  {
 1246   4                       if(StartRem[2] != 0)
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 20  

 1247   4                      {
 1248   5                          RemFlag[2] = 0;
 1249   5                          SendParam();
 1250   5                          ModeHint(); 
 1251   5                          //UpdataUI();
 1252   5                          EnterPage(PAGE_SET);
 1253   5                          StartRem[2] = 0;
 1254   5                       }
 1255   4                  }
 1256   3                  break;
 1257   3              }
 1258   2               
 1259   2               case 3:
 1260   2              {
 1261   3                  if(SysParam.RemCtlFlag)
 1262   3                  {
 1263   4                       if(!RemFlag[3])
 1264   4                      {
 1265   5                          RemFlag[3] = 1;
 1266   5                          StartRem[3]++;
 1267   5                          EnterPage(PAGE_REM);
 1268   5                          
 1269   5                       }
 1270   4                  }
 1271   3                  else
 1272   3                  {
 1273   4                       if(StartRem[3] != 0)
 1274   4                      {
 1275   5                          RemFlag[3] = 0;
 1276   5                          SendParam();
 1277   5                          ModeHint(); 
 1278   5                          //UpdataUI();
 1279   5                          EnterPage(PAGE_TIME);
 1280   5                          StartRem[3] = 0;
 1281   5                       }
 1282   4                  }
 1283   3                 break; 
 1284   3              }
 1285   2               
 1286   2          }
 1287   1          //printf("REmFlag2 = %d\r\n",SysParam.RemCtlFlag);
 1288   1      }
 1289          
 1290          
 1291          void RemCtlWrite()
 1292          {
 1293   1          SendRemCtlCmd(1, CMD_WRITE_REG, MODBUS_PARAM_ADD, 2, (BYTE *)&ModBusParam);
 1294   1          Delay(50);
 1295   1          SendRemCtlCmd(1, CMD_WRITE_REG, MODBUS_STATUS_ADD, 1, (BYTE *)&ModBusStatus);
 1296   1          Delay(50);
 1297   1          SendRemCtlCmd(1, CMD_WRITE_REG, MODBUS_INFO_ADD, 1, (BYTE *)&ModBusInfo);
 1298   1      }
 1299          
 1300          void RemCtlTask()
 1301          {   
 1302   1              WORD RegCnt = 3;
 1303   1              
 1304   1      //    if (RunStatus.Running)
 1305   1      //    {
 1306   1               if(RemReadflag == 1)
 1307   1              {
 1308   2                  RemReadflag = 0;
 1309   2      
 1310   2                  SendRemCtlCmd(1, CMD_READ_REG, MODBUS_PARAM_ADD, RegCnt, NULL);
 1311   2                  Delay(50);
 1312   2                  SendRemCtlCmd(1, CMD_READ_REG, MODBUS_STATUS_ADD, 11, NULL);
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 21  

 1313   2                  Delay(50);
 1314   2      //            SendRemCtlCmd(1, CMD_READ_REG, MODBUS_INFO_ADD, 3, NULL);
 1315   2      //            Delay(50);
 1316   2      //            SendRemCtlCmd(1, CMD_READ_REG, MODBUS_REM_CTL, 1, NULL);
 1317   2      //            Delay(50);
 1318   2              }
 1319   1          //}
 1320   1      }
 1321          
 1322          void main(void)
 1323          {
 1324   1          BYTE i = 0;
 1325   1          SysInit();
 1326   1          IoInit();
 1327   1          PW_MAIN(0);  // 主电源
 1328   1          LedInit();
 1329   1          
 1330   1          RUN_LED(1);
 1331   1         
 1332   1          Delay(200);
 1333   1          
 1334   1          Timer0Init();
 1335   1          Delay(200);
 1336   1          Adc_Init();
 1337   1          Delay(200);
 1338   1          
 1339   1          UART1_config();
 1340   1          UART2_config();
 1341   1          UART3_config();
 1342   1          UART4_config();
 1343   1          ClearUart1Buf();
 1344   1          ClearUart2Buf();
 1345   1          ClearUart3Buf();
 1346   1          ClearUart4Buf();
 1347   1          
 1348   1          // 待CPU稳定了再读参数
 1349   1          Delay(500);
 1350   1          ReadParam();
 1351   1          Delay(200);
 1352   1      
 1353   1          SyncModBusDev();
 1354   1          //RemCtlWrite();
 1355   1          
 1356   1          
 1357   1          RUN_LED(0);
 1358   1      
 1359   1          #if 0
                   while(1)
                   {
                       RUN_LED(0);
                       Delay(800);
                       RUN_LED(1);
                       Delay(200);
                   }
                   #endif
 1368   1          
 1369   1          
 1370   1          EA = 1;     //打开总中断
 1371   1      
 1372   1          WDT_CONTR |= (1<<5) |  7;  // 启动开门狗，约8秒
 1373   1      
 1374   1          Delay(200);
 1375   1          InitLcd();
 1376   1          SysParam.RemCtlFlag = 0;
 1377   1          PageSwitch = 0;
 1378   1          while(1)
C251 COMPILER V5.60.0,  main                                                               07/10/23  09:26:56  PAGE 22  

 1379   1          {
 1380   2              //printf("RemCtlFlag = %d\r\n",SysParam.RemCtlFlag);
 1381   2              TimerTask();
 1382   2              HndInput();
 1383   2               
 1384   2              //RemCtlWrite();
 1385   2               
 1386   2              Uart1Hnd();
 1387   2              Uart2Hnd();
 1388   2              Uart3Hnd();
 1389   2              RemPageCtl();
 1390   2              
 1391   2              FlowTask();
 1392   2              
 1393   2              Uart4Hnd();
 1394   2              RemCtlTask();
 1395   2          }
 1396   1      }
 1397          
 1398          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      5273     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       214     ------
  xdata-const size     =    ------     ------
  edata size           =       149     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       261     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
