C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\obj\main.obj
COMPILER INVOKED BY: D:\KeilMDK\C251\BIN\C251.EXE main.c XSMALL OPTIMIZE(0,SPEED) BROWSE INCDIR(.\Ads1110;.\Flash;.\mcp4
                    -725;.\IIC;.\MwPro;.\Uart;.\Lcd;.\ModBus;.\Temperaturn) PRINT(.\obj\main.lst) OBJECT(.\obj\main.obj) 

stmt  level    source

    1          #include "main.h"
    2          #include "mcp4725.h"
    3          #include "Lcd.h"
    4          #include "LcdApp.h"
    5          #include "ModBus.h"
    6          #include "Temper.h"
    7          #include "FlowMeter.h"
    8          #include "ModBusDev.h"
    9          #include "ModBusHost.h"
   10          
   11          
   12          BYTE code VERSION = 100;  // V1.0.0
   13          
   14          BYTE xdata StrTmp[64] = {0};
   15          //BYTE xdata Valve[8] = {0};
   16          
   17          BYTE ChannelError[FLOW_METER_CNT] ={0};
   18          
   19          #define Log //((CSampDemoDlg *)theApp.m_pMainWnd)->AddLog
   20          
   21          #define PARAM_SIGN  0x3132
   22          SYS_PARAM xdata SysParam;
   23          RUN_STATUS xdata RunStatus;
   24          REM_REGADDR xdata RemRegAddr;
   25          
   26          float SimFlow = 35.0;
   27          
   28          u16 SendFlowTim = 0;
   29          BYTE SendFlowFlag = 0;
   30          
   31          u16 RemReadTim = 0;     //远程控制读从机开始时间
   32          BYTE RemReadflag = 0;   //远程控制读从机开始标志
   33          //BYTE RemPageflag = 0;
   34          
   35          u16 LcdBusyTim = 0;
   36          BYTE LcdBusyFlag = 0;
   37          BYTE ChNum = 1;
   38          
   39          BYTE g_Output[OUT_IO_COUNT]      = {0,0,0,0,0};   // 上电蓝灯亮 // 
   40          BYTE g_OutStatus[OUT_IO_COUNT]   = {0,0,0,0,0};
   41          
   42          BYTE PageSwitch = 0;                                //远程控制界面选择
   43          //BYTE StartRem[5] = {0,0,0,0,0};
   44          //BYTE RemFlag[5] = {0,0,0,0,0};
   45          
   46          
   47          u16  Timer0Cnt = 0;
   48          
   49          BYTE g_Key_Confrom  = 0; 
   50          BYTE g_Key_Power  = 0; 
   51          BYTE g_Key_Input  = 0; 
   52          BYTE Input_Status = 0;
   53          
   54          WORD gRunTime = 0;
   55          
   56          void DebugMsg(char *msg)
   57          {
   58   1          BYTE len = (BYTE)strlen(msg);
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 2   

   59   1          //Uart1Send((BYTE *)msg,len);
   60   1      }
   61          
   62          void DebugInt(int msg)
   63          {
   64   1          memset(StrTmp,0,64);
   65   1          sprintf(StrTmp,"%x\r\n",msg);
   66   1          DebugMsg(StrTmp);
   67   1      }
   68          
   69          void DumpCmd(BYTE *dat, BYTE len)
   70          {
   71   1          BYTE i;
   72   1          memset(StrTmp,0,64);
   73   1          for (i=0;i<len;i++)
   74   1          {
   75   2              if (strlen(StrTmp) >= 60)
   76   2              {
   77   3                  break;
   78   3              }
   79   2              sprintf(&StrTmp[i*3], "%02X ", dat[i]);
   80   2          }
   81   1          sprintf(&StrTmp[i*3], "\r\n");
   82   1          DebugMsg(StrTmp);
   83   1      }
   84          
   85          
   86          void Error()
   87          {
   88   1          while(1)
   89   1          {
   90   2              RUN_LED(1);
   91   2              Delay(50);
   92   2              RUN_LED(0);
   93   2              Delay(50);
   94   2          }
   95   1          
   96   1      }
   97          
   98          
   99          void SysInit()
  100          {
  101   1          HIRCCR = 0x80;           // 启动内部高速IRC
  102   1          while(!(HIRCCR & 1));
  103   1          CLKSEL = 0;              
  104   1      }
  105          
  106          void IoInit()
  107          {
  108   1          EAXFR = 1;
  109   1          WTST = 0;   //设置程序指令延时参数，赋值为0可将CPU执行指令的速度设置为最快
  110   1      
  111   1          P0M1 = 0x00;   P0M0 |= (1<<4) ;                     // P0.0 P0.1 P0.4 推挽输出
  112   1          P1M1 = (1<<4)|(1<<3);   P1M0 = 0x00;                       //设置为准双向口
  113   1          P2M1 = 0x00;   P2M0 |= 0x00;                      // P2.2 推挽输出
  114   1          P3M1 = 0x00;   P3M0 |= (1<<2)|(1<<3)|(1<<4);        //设置为准双向口
  115   1          P4M1 = 0x00;   P4M0 = 0x00;                       //设置为准双向口
  116   1          P5M1 = 0x00;   P5M0 |= (1<<0) | (1<<2);             //设置为准双向口
  117   1          P6M1 = 0x00;   P6M0 |= (1<<7);     //设置为准双向口
  118   1          P7M1 = 0x00;   P7M0 = 0x00;                         //设置为准双向口
  119   1      }
  120          
  121          
  122          void SensorInit()
  123          {
  124   1          // P1.0 -- 下降缘中断
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 3   

  125   1          P1IM0 = 0;
  126   1          P1IM1 = 0;
  127   1      
  128   1          // 优先级2
  129   1          //PIN_IP  |= (1<<1);
  130   1          PINIPH |= (1<<1);
  131   1          //P1_IP  = 1; // |= (1<<1);
  132   1          //P1_IPH = 1; //|= (1<<1);
  133   1      
  134   1          // 允许中断
  135   1          P1INTE |= (1<<0) | (1<<1) | (1<<4) | (1<<5);
  136   1      }
  137          
  138          
  139          
  140          void Timer0Init()
  141          {
  142   1          AUXR = 0x00;    //Timer0 set as 12T, 16 bits timer auto-reload, 
  143   1          TH0 = (u8)(Timer0_Reload / 256);
  144   1          TL0 = (u8)(Timer0_Reload % 256);
  145   1          ET0 = 1;    //Timer0 interrupt enable
  146   1          TR0 = 1;    //Tiner0 run
  147   1          
  148   1          // 中断优先级3
  149   1          PT0  = 0;
  150   1          PT0H = 0;
  151   1      }
  152          
  153          // 10ms 中断一下
  154          void Timer0Int (void) interrupt 1
  155          {
  156   1          Timer0Cnt ++;
  157   1      }
  158          
  159          #if 0
               // 公用中断服务程序
               void CommInt (void) interrupt 13
               {
                   u8 intf =  P1INTF;
                   
                   if (intf)
                   {
                       P1INTF = 0;
               
                       if (intf & (1<<0))  // P1.0 中断
                       {
                           Counter[0] ++;
                       }
               
                       if (intf & (1<<1))  // P1.1 中断
                       {
                           Counter[1] ++;
                       }
               
                       if (intf & (1<<4))  // P1.4 中断
                       {
                           Counter[2] ++;
                       }
               
                       if (intf & (1<<5))  // P1.5 中断
                       {
                           Counter[3] ++;
                       }
                   }
                   
               }
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 4   

               #endif
  192          
  193          
  194          void OutCtl(alt_u8 id, alt_u8 st)
  195          {
  196   1          if (g_OutStatus[id] == st)
  197   1          {
  198   2              return;
  199   2          }
  200   1      
  201   1          g_OutStatus[id] = st;
  202   1          
  203   1          switch(id)
  204   1          {   
  205   2              case LIGHT_BLUE: 
  206   2              {
  207   3                  (st)? BLU_LIGHT(1) : BLU_LIGHT(0); 
  208   3                  break;
  209   3              }
  210   2          
  211   2              case LIGHT_YELLOW: 
  212   2              {
  213   3                  (st)? YEL_LIGHT(1):YEL_LIGHT(0);
  214   3                  break;
  215   3              }
  216   2      
  217   2              case GAS_BUMP:      //泵
  218   2              {
  219   3                  (st)? BUMP_M(1) : BUMP_M(0);
  220   3                  break;
  221   3              }
  222   2      
  223   2              case EX_FAN:        //风扇
  224   2              {
  225   3                  (st)? FANS_M(1) : FANS_M(0);
  226   3                  break;
  227   3              }
  228   2      
  229   2              case ALARM_SOUND:   //报警
  230   2              {
  231   3                  (st)? ALARM(1) : ALARM(0);       
  232   3                  break;
  233   3              }
  234   2          }
  235   1      
  236   1          
  237   1      }
  238          
  239          void OutFlash(alt_u8 id)
  240          {
  241   1          static alt_u16 OutTimer[OUT_IO_COUNT] = {0,0,0,0,0};
  242   1          if (OutTimer[id] ++ > LED_FLASH_TIME/10)
  243   1          {
  244   2              OutTimer[id] = 0;
  245   2              if (g_OutStatus[id] == 1)
  246   2              {
  247   3                  OutCtl(id, 0);
  248   3              }
  249   2              else
  250   2              {
  251   3                  OutCtl(id, 1);
  252   3              }
  253   2          }
  254   1      }
  255          
  256          void IoCtlTask()
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 5   

  257          {
  258   1          alt_u8 i;
  259   1          for (i=0;i<OUT_IO_COUNT;i++)
  260   1          {
  261   2              if (g_Output[i] == 2)
  262   2              {
  263   3                  OutFlash(i);
  264   3              }
  265   2              else
  266   2              {
  267   3                  OutCtl(i, g_Output[i]);
  268   3              }
  269   2          }
  270   1      }
  271          
  272          // 板载指示灯
  273          void RunLed(u16 dt)
  274          {   
  275   1          static u16 tm = 0;
  276   1          u16 to = 3000;
  277   1          tm += dt;
  278   1      
  279   1          if (tm > to)
  280   1          {
  281   2              tm = 0;
  282   2              RUN_LED(0);
  283   2          }
  284   1          else if (tm > (to-100))
  285   1          {
  286   2              RUN_LED(1);
  287   2          }
  288   1      }
  289          
  290          
  291          
  292          void Task1s()
  293          {
  294   1          static BYTE tm = 0;
  295   1      
  296   1          CLR_WDT = 1;  // 喂狗
  297   1          tm++;
  298   1          if(tm == 10)
  299   1          {
  300   2              ADC_Temp();
  301   2              SyncModBusDev();
  302   2              tm = 0;
  303   2          } 
  304   1          
  305   1          if((tm == 6)||(tm == 3))
  306   1          {
  307   2              GetRetCode();
  308   2          }
  309   1          
  310   1          if(tm == 9)
  311   1          {
  312   2              if (RunStatus.Running)
  313   2              {  
  314   3                  DevRun();
  315   3              }
  316   2          }
  317   1          //RemCtlWrite();
  318   1      }
  319          
  320          
  321          void TimerTask()
  322          {
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 6   

  323   1          u16 delta = 0;
  324   1          static u16 Time1s = 0;
  325   1          
  326   1          if (Timer0Cnt)
  327   1          {
  328   2              delta = Timer0Cnt * 10;
  329   2              Timer0Cnt = 0;
  330   2      
  331   2              if (RX2_Cnt > 0)
  332   2              {
  333   3                  Rx2_Timer += delta;
  334   3              }
  335   2      
  336   2              if(RX3_Cnt > 0)
  337   2              {
  338   3                  Rx3_Timer += delta;
  339   3              }
  340   2              
  341   2              if(RX4_Cnt > 0)
  342   2              {
  343   3                  Rx4_Timer += delta;
  344   3              }
  345   2              
  346   2              SendFlowTim += delta;
  347   2              if(SendFlowTim > 220)
  348   2              {
  349   3                  SendFlowTim = 0;
  350   3                  SendFlowFlag = 1;
  351   3              }
  352   2      
  353   2              RemReadTim += delta;
  354   2              if(RemReadTim > 250)
  355   2              {
  356   3                  RemReadTim = 0;
  357   3                  RemReadflag = 1;
  358   3              }
  359   2      
  360   2              if (gRunTime < 5000)
  361   2              {
  362   3                  gRunTime += delta;
  363   3              }
  364   2      
  365   2              //if (g_CommIdleTime < 300)
  366   2              //{
  367   2                  //g_CommIdleTime += delta;
  368   2              //}
  369   2      
  370   2              #ifdef IRDA_FUN
                       if (IrDAStart == 1)
                       {
                           IrDATimer += delta;
                       }
                       #endif
  376   2      
  377   2              Time1s += delta;
  378   2              if (Time1s >= 100)
  379   2              {
  380   3                  Time1s = 0;
  381   3                  Task1s();
  382   3              }
  383   2              RunLed(delta);
  384   2              IoCtlTask();
  385   2              GetValve();
  386   2              ShowRemCh();
  387   2          }
  388   1      }
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 7   

  389          
  390          
  391          
  392          void Delay(WORD ms)
  393          {
  394   1          WORD t = 1000;
  395   1          while(ms--)
  396   1          {
  397   2              for (t=0;t<1000;t++) ;
  398   2          }
  399   1      }
  400          
  401          
  402          WORD ParamCheck(BYTE *buf, WORD len)
  403          {
  404   1          WORD dwSum = 0;
  405   1          WORD i;
  406   1      
  407   1          for (i = 0; i < len; i++)
  408   1          {
  409   2              dwSum += buf[i];
  410   2          }
  411   1      
  412   1          return dwSum;
  413   1      }
  414          
  415          /*
  416          void DefSenParam()
  417          {
  418              BYTE i;
  419              for (i=0; i<SENSOR_COUNT; i++)
  420              {
  421                  SysParam.SenParam[i].LOW_REVISE_COE_A = 1;
  422                  SysParam.SenParam[i].LOW_REVISE_COE_B = 1;
  423                  SysParam.SenParam[i].LOW_REVISE_COE_C = 1;
  424          
  425                  SysParam.SenParam[i].HIG_REVISE_COE_A = 1;
  426                  SysParam.SenParam[i].HIG_REVISE_COE_B = 1;
  427                  SysParam.SenParam[i].HIG_REVISE_COE_C = 1;
  428          
  429                  SysParam.SenParam[i].SUPER_REVISE_COE_A = 1;
  430                  SysParam.SenParam[i].SUPER_REVISE_COE_B = 1;
  431                  SysParam.SenParam[i].SUPER_REVISE_COE_C = 1;
  432          
  433                  SysParam.SenParam[i].DET_THR_1 = 500;
  434                  SysParam.SenParam[i].DET_THR_2 = 150;
  435                  SysParam.SenParam[i].DET_THR_3 = 150;
  436          
  437                  SysParam.SenParam[i].DET_TIME = 1000;
  438                  SysParam.SenParam[i].HV_THR = 1000;
  439              }
  440          }
  441          */
  442          
  443          /*
  444          void DefSenAlarm()
  445          {
  446              BYTE i;
  447              for (i=0; i<SENSOR_COUNT; i++)
  448              {
  449                  SysParam.AlmParam[i].DOSE_RATE_ALARM_1 = 300;
  450                  SysParam.AlmParam[i].DOSE_RATE_ALARM_2 = 400;
  451                  SysParam.AlmParam[i].CUM_DOSE_RATE_ALARM_1 = 300;
  452                  SysParam.AlmParam[i].CUM_DOSE_RATE_ALARM_2 = 400;
  453                  SysParam.AlmParam[i].INVALID_ALRAM_1 = 8000;
  454                  SysParam.AlmParam[i].INVALID_ALRAM_2 = 10000;
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 8   

  455              }
  456          }
  457          */
  458          
  459          void ReadParam()
  460          {
  461   1          EEPROM_read(0, (BYTE *)&SysParam, sizeof(SYS_PARAM));
  462   1      
  463   1          #if 0
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(SYS_PARAM));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(HOST_SENSOR_PARAM));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(HOST_ALRAM_PARA));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(float));
                   DebugMsg((char *)StrTmp);
                   
                   //Rs485Send((BYTE *)&SysParam, sizeof(SYS_PARAM));
                   
                   
                   if (SysParam.Sign != PARAM_SIGN)
                   {
                       DebugMsg("Sign error. \r\n");
                   }
               
                   if (SysParam.Sum != ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2))
                   {
                       DebugMsg("Param Check error. \r\n");
                   }
                   #endif
  493   1      
  494   1         
  495   1          if ( (SysParam.Sign != PARAM_SIGN) ||
  496   1               (SysParam.Sum != ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2)) )
  497   1          {
  498   2              //SysParam.Sign = PARAM_SIGN;
  499   2              //SysParam.Address = 1;
  500   2              ParamDef();
  501   2              //DefSenParam();
  502   2              //DefSenAlarm();
  503   2              WriteParam();
  504   2      
  505   2              //DebugMsg("Def Param. \r\n");
  506   2          }
  507   1      }
  508          
  509          
  510          void WriteParam()
  511          {
  512   1          EA = 0;    
  513   1          
  514   1          EEPROM_SectorErase(0);
  515   1          EEPROM_SectorErase(512);
  516   1          SysParam.Sum = ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2);
  517   1          if (!EEPROM_write(0, (BYTE *)&SysParam, sizeof(SYS_PARAM)))
  518   1          {
  519   2              Error();
  520   2          }
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 9   

  521   1      
  522   1          EA = 1;     //打开总中断
  523   1      }
  524          
  525          BYTE GetInput()
  526          {
  527   1          // 当前只有一个开关机状态 P2.1
  528   1          static BYTE his = LOCK_BIT();
  529   1          BYTE st = POWER_LOCK();
  530   1      
  531   1          if (st != his)
  532   1          {
  533   2              Delay(50);
  534   2              if ( st == POWER_LOCK() )
  535   2              {
  536   3                  his = st;
  537   3                  return st;
  538   3              }
  539   2          }
  540   1      
  541   1          return 0xFF;
  542   1      }
  543          
  544          
  545          void PowerOff()
  546          {
  547   1          PW_MAIN(0);
  548   1      
  549   1          while(1)
  550   1          {
  551   2              ;
  552   2          }
  553   1      }
  554          
  555          void HndInput()
  556          {
  557   1          static bool em = false;
  558   1          if(STOP_M() == 0)
  559   1          {
  560   2              Delay(10);
  561   2              if (STOP_M() == 0)
  562   2              {
  563   3                  if (RunStatus.Running)
  564   3                  {
  565   4                      StopSamp(false);
  566   4                  }
  567   3              }
  568   2      
  569   2              if (em == false)
  570   2              {
  571   3                  em = true;
  572   3                  ShowEmStop(em);
  573   3              }
  574   2          }
  575   1          else
  576   1          {
  577   2              if (em)
  578   2              {
  579   3                  em = false;
  580   3                  ShowEmStop(em);
  581   3              }
  582   2          }
  583   1      }
  584          
  585          /*
  586          void ReportInput()
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 10  

  587          {
  588              BYTE PwOff = POWER_OFF;
  589              
  590              if (g_CommIdleTime > 200)
  591              {
  592                  if (g_Key_Confrom)
  593                  {
  594                      g_Key_Confrom = 0;
  595                      SendPcCmd(0, CMD_CERTAINKEY, NULL, 0);
  596                      return;
  597                  }
  598          
  599                  if (g_Key_Power)
  600                  {
  601                      g_Key_Power = 0;
  602                      SendPcCmd(0, CMD_POWER, &PwOff, 1);
  603                      return;
  604                  }
  605          
  606                  #if 0
  607                  if (g_Key_Input)
  608                  {
  609                      g_Key_Input = 0;
  610                      SendPcCmd(0, CMD_INPUT, &Input_Status, 1);
  611                  }
  612                  #endif
  613              }
  614          }
  615          */
  616          
  617          void LedInit()
  618          {
  619   1          // 初始状态都为0
  620   1      
  621   1          // 指示灯
  622   1          YEL_LIGHT(0);   // 黄灯
  623   1          BLU_LIGHT(0);   // 蓝灯
  624   1          
  625   1          CloseValve();   // 电磁阀
  626   1          BUMP_M(0);      // 泵
  627   1          FANS_M(0);      // 风扇
  628   1          ALARM(0);       // 报警音
  629   1      }
  630          
  631          
  632          void ParamDef()
  633          {
  634   1          BYTE i;
  635   1          
  636   1          SysParam.Sign     = PARAM_SIGN;
  637   1          SysParam.Address = 1;
  638   1          SysParam.BkLight = 50;
  639   1      
  640   1          SysParam.SampMode = MODE_TIME;
  641   1          SysParam.SampTime = 5;  
  642   1          SysParam.SampVol   = 2;
  643   1          SysParam.AlarmThres   = 10;
  644   1          for (i=0;i<CHANNLE_NUM;i++)
  645   1          {
  646   2              SysParam.SampFlow[i] = 35;
  647   2              //SysParam.Valve[i] = 0;
  648   2          }
  649   1      
  650   1          SysParam.Enable = 0x1F;
  651   1          SysParam.RemCtlFlag = false;
  652   1      
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 11  

  653   1          RemRegAddr.SypAddr = MODBUS_PARAM_ADD;
  654   1          RemRegAddr.StuAddr = MODBUS_STATUS_ADD;
  655   1          RemRegAddr.InfoAddr = MODBUS_INFO_ADD;
  656   1      }
  657          
  658          void SaveParam()
  659          {
  660   1          //CString t;
  661   1          //t.Format(_T("SaveParam: %02X\r\n"), SysParam.Enable);
  662   1          //Log(t);
  663   1          //DebugMsg("123");
  664   1          WriteParam();
  665   1      }
  666          
  667          
  668          void UpdataUI()
  669          {
  670   1          BYTE i;
  671   1          for (i=0;i<CHANNLE_NUM;i++)
  672   1          {
  673   2              ChannelAlarm[i] = ((SysParam.Enable & (1<<i)) == 0)?0:1;
  674   2          }
  675   1          ShowStatus();
  676   1          Delay(200);
  677   1          StatusColor(true);
  678   1      }
  679          
  680          void InitLcd()
  681          {   
  682   1          memset(&RunStatus, 0, sizeof(RUN_STATUS));
  683   1          memset(&RunInfo, 0, sizeof(RUN_INFO));
  684   1          memset(&RealFlow, 0, sizeof(RealFlow));
  685   1          
  686   1          //ParamDef();
  687   1          ModeHint();
  688   1          Delay(200);
  689   1          HideModule(MP_HINT_END);
  690   1          Delay(200);
  691   1          UpdataUI();    
  692   1          Delay(200);
  693   1          SendParam();
  694   1          Delay(200);
  695   1          SetBkLight(false);
  696   1          Delay(200);
  697   1          ShowDevInfo();
  698   1          Delay(200);
  699   1      }
  700          
  701          
  702          void GetFlow()
  703          {
  704   1          BYTE i;
  705   1          WORD  w;
  706   1          DWORD d;
  707   1      
  708   1          
  709   1          for (i=0;i<CHANNLE_NUM;i++)
  710   1          {
  711   2              if (SysParam.Enable & (1<<i))
  712   2              {
  713   3                  RunStatus.Flow[i] = RealFlow[i].val;  // 模拟 -- 实际要从流量计中读取
  714   3                  w = (WORD)(RunStatus.Flow[i]*10);
  715   3                  RunInfo.ChFlow[i].Flow = SwWord(w);
  716   3                  
  717   3                  RunStatus.Volume[i] =  RealFlow[i].Totol; 
  718   3                  w = (WORD)(RunStatus.Volume[i]*10);
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 12  

  719   3                  RunInfo.ChFlow[i].Vol = SwWord(w);
  720   3              }
  721   2          }
  722   1      
  723   1          // 总流量
  724   1          RunStatus.TotleFlow = RealFlow[8].val;
  725   1          d = (DWORD)(RealFlow[8].val*10);
  726   1          RunInfo.TotFlow.Flow = SwDWord(d);
  727   1      
  728   1          // 总体积
  729   1          RunStatus.TotleVol = RealFlow[8].Totol;
  730   1          d = (DWORD)(RealFlow[8].Totol*10);
  731   1          RunInfo.TotFlow.Vol   = SwDWord(d);
  732   1      }
  733          
  734          void StartSamp()
  735          {
  736   1          memset(&RunStatus, 0, sizeof(RUN_STATUS));
  737   1          memset(&RunInfo, 0, sizeof(RUN_INFO));
  738   1          memset(&RealFlow, 0, sizeof(RealFlow));
  739   1          
  740   1          RunStatus.Running = true;
  741   1          g_Output[LIGHT_BLUE] = 1;
  742   1          CheckValve();
  743   1          OpenPump();
  744   1          SetStartBtn(0);
  745   1      
  746   1      }
  747          
  748          void StopSamp(bool Auto)
  749          {
  750   1          ClosePump();
  751   1          memset(RealFlow,0, sizeof(RealFlow));
  752   1      
  753   1          RunStatus.Running = false;
  754   1          g_Output[LIGHT_BLUE] = 0;
  755   1          
  756   1          SetStartBtn(1);  // 按钮自动变为“开始”
  757   1          
  758   1          if (Auto)  // 自动结束
  759   1          {
  760   2              // 显示取样结束提示框
  761   2              ShowModule(MP_HINT_END, REG_HINT_END);
  762   2          }
  763   1      }
  764          
  765          // 定时模式
  766          void TimingMode()
  767          {
  768   1          if (RunStatus.RunTime >= ((DWORD)SysParam.SampTime) * 60)
  769   1          {
  770   2              StopSamp(true);
  771   2          }
  772   1      }
  773          
  774          
  775          // 定量模式
  776          void VolumeMode()
  777          {
  778   1          if (RunStatus.TotleVol >= SysParam.SampVol)
  779   1          {
  780   2              StopSamp(true);
  781   2          }
  782   1      }
  783          
  784          
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 13  

  785          void RunCheck()
  786          {
  787   1          switch (SysParam.SampMode)
  788   1          {
  789   2              case MODE_TIME:  TimingMode();  break;
  790   2              case MODE_VOL:   VolumeMode();  break;
  791   2          }
  792   1      }
  793          
  794          void AbnorAlaerm()
  795          {   
  796   1          BYTE i;
  797   1          bool HaveAlarm = false;
  798   1      
  799   1          
  800   1          
  801   1          for(i = 0;i < CHANNLE_NUM;i++)
  802   1          {
  803   2              if( (ChannelAlarm[i] == ALM_FLOW_ABNOR) ||
  804   2                  (ChannelAlarm[i] ==  ALM_FLOW_LOW) || 
  805   2                  (ChannelAlarm[i] == ALM_FLOW_HIGH)  )
  806   2              {
  807   3                  HaveAlarm = true;
  808   3                  break;
  809   3              }
  810   2          }
  811   1      
  812   1          if (HaveAlarm)
  813   1          {
  814   2              g_Output[LIGHT_YELLOW] = 1;
  815   2              g_Output[ALARM_SOUND] = 2;
  816   2          }
  817   1          else
  818   1          {
  819   2              g_Output[LIGHT_YELLOW] = 0;
  820   2              g_Output[ALARM_SOUND] = 0;
  821   2          }
  822   1      }
  823          void CheckAlarm()
  824          {
  825   1          BYTE i;
  826   1          float flow;
  827   1          
  828   1          for (i=0;i<CHANNLE_NUM;i++)
  829   1          {
  830   2              if (SysParam.Enable & (1<<i))
  831   2              {
  832   3                  flow = RunStatus.Flow[i];
  833   3                  if (flow > SysParam.SampFlow[i]*(100+SysParam.AlarmThres)/100)
  834   3                  {
  835   4                      ChannelAlarm[i] = ALM_FLOW_HIGH;
  836   4                  }
  837   3                  else if (flow < SysParam.SampFlow[i]*(100-SysParam.AlarmThres)/100)
  838   3                  {
  839   4                      ChannelAlarm[i] = ALM_FLOW_LOW;
  840   4                  }
  841   3                  else
  842   3                  {
  843   4                      ChannelAlarm[i] = ALM_FLOW_NOR;
  844   4                  }
  845   3              }
  846   2              else
  847   2              {
  848   3                  ChannelAlarm[i] = ALM_CH_DISABLE;
  849   3              }
  850   2              
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 14  

  851   2              if( (ChannelError[i] > 3) && (ChannelAlarm[i] != ALM_CH_DISABLE) )
  852   2              {
  853   3                  ChannelAlarm[i] = ALM_FLOW_ABNOR;
  854   3              }
  855   2          }
  856   1      
  857   1          if (memcmp(HisAlarm,ChannelAlarm,CHANNLE_NUM) != 0)
  858   1          {
  859   2              // 报警有变化才更新界面
  860   2              Delay(200);
  861   2              ShowStatus();
  862   2              Delay(200);
  863   2              AbnorAlaerm();
  864   2              StatusColor(false);
  865   2      
  866   2              memcpy(HisAlarm,ChannelAlarm,8);
  867   2          }
  868   1      }
  869          
  870          // 1秒运行一次
  871          void DevRun()
  872          {
  873   1          RunStatus.RunTime ++;
  874   1          
  875   1          // 1. 获取流量
  876   1          GetFlow();
  877   1      
  878   1          // 2. 显示流量和状态
  879   1          ShowFlow();
  880   1          //Delay(200);
  881   1          
  882   1          // 3. 检查报警状态  
  883   1          if (RunStatus.RunTime > 10)
  884   1          {
  885   2              // 运行时间大于10秒才检测
  886   2              CheckAlarm();
  887   2          }
  888   1          
  889   1          // 4. 根据模式判断是否结束取样
  890   1          RunCheck();
  891   1      }
  892          
  893          
  894          //获取电磁阀状态
  895          void GetValve()
  896          {
  897   1          BYTE i;
  898   1          for(i = 0;i<CHANNLE_NUM;i++)
  899   1          {
  900   2              if(SysParam.Enable & (1<<i))
  901   2              {
  902   3                  RemChStatus[i] = 1;
  903   3                 //SysParam.Valve[i] = 1;
  904   3              }
  905   2              else
  906   2              {
  907   3                  RemChStatus[i] = 0;
  908   3      //           SysParam.Valve[i] = 0;
  909   3              }
  910   2          }
  911   1      
  912   1      }
  913          
  914          //查询电磁阀状态
  915          void CheckValve()
  916          {
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 15  

  917   1          BYTE i;
  918   1          for(i = 0;i<CHANNLE_NUM;i++)
  919   1          {
  920   2              if(RemChStatus[i])//(SysParam.Valve[i])
  921   2              {
  922   3                  switch(i)
  923   3                  {
  924   4                      case 0 : VALVE0(1); break;
  925   4                      case 1 : VALVE1(1); break;
  926   4                      case 2 : VALVE2(1); break;
  927   4                      case 3 : VALVE3(1); break;
  928   4                      case 4 : VALVE4(1); break;
  929   4                      case 5 : VALVE5(1); break;
  930   4                      case 6 : VALVE6(1); break;
  931   4                      case 7 : VALVE7(1); break;  
  932   4                  }
  933   3              }
  934   2              else
  935   2              {
  936   3                  switch(i)
  937   3                  {
  938   4                      case 0 : VALVE0(0); break;
  939   4                      case 1 : VALVE1(0); break;
  940   4                      case 2 : VALVE2(0); break;
  941   4                      case 3 : VALVE3(0); break;
  942   4                      case 4 : VALVE4(0); break;
  943   4                      case 5 : VALVE5(0); break;
  944   4                      case 6 : VALVE6(0); break;
  945   4                      case 7 : VALVE7(0); break;  
  946   4                  }
  947   3              }
  948   2          }
  949   1          Delay(20);
  950   1      }
  951          
  952          //关闭电磁阀
  953          void CloseValve()
  954          {
  955   1          VALVE0(0);
  956   1          VALVE1(0);
  957   1          VALVE2(0);
  958   1          VALVE3(0);
  959   1          VALVE4(0);
  960   1          VALVE5(0);
  961   1          VALVE6(0);
  962   1          VALVE7(0);
  963   1          Delay(20);
  964   1      }
  965          // 开启气泵
  966          void OpenPump()
  967          {
  968   1          //BUMP_M(1);
  969   1          g_Output[GAS_BUMP] = 1;
  970   1      }
  971          
  972          
  973          // 停止气泵
  974          void ClosePump()
  975          {
  976   1          //BUMP_M(0);
  977   1          CloseValve();
  978   1          g_Output[GAS_BUMP] = 0;
  979   1      }
  980          
  981          void SendReadFlowCmd(BYTE ch)
  982          {
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 16  

  983   1          ChannelError[ch-1] ++;
  984   1          SendReadFlow(ch);    
  985   1      }
  986          
  987          WORD GetAlarm(BYTE i)
  988          {
  989   1          //BYTE i;
  990   1      
  991   1      //    for (i=0;i<8;i++)
  992   1      //    {
  993   1              if(ChannelAlarm[i] == ALM_CH_DISABLE)
  994   1              {
  995   2                  return ALM_CH_DISABLE;
  996   2              }
  997   1              if (ChannelAlarm[i] ==  ALM_FLOW_ABNOR)
  998   1              {
  999   2                  return ALM_FLOW_ABNOR;
 1000   2              }
 1001   1              
 1002   1              if (ChannelAlarm[i] ==  ALM_FLOW_HIGH)
 1003   1              {
 1004   2                  return ALM_FLOW_HIGH;
 1005   2              }
 1006   1      
 1007   1              if (ChannelAlarm[i] ==  ALM_FLOW_LOW)
 1008   1              {
 1009   2                  return ALM_FLOW_LOW;
 1010   2              }
 1011   1          //}
 1012   1      
 1013   1          return ALM_FLOW_NOR;
 1014   1      }
 1015          
 1016          void SyncModBusDev()
 1017          {
 1018   1          BYTE i;
 1019   1          memset(&ModBusParam, 0, sizeof(MODBUS_PARAM));
 1020   1          //ModBusParam.AlamrThres = SysParam.AlarmThres;
 1021   1          ModBusParam.ChEnable =   SysParam.Enable;
 1022   1      
 1023   1      //    for (i=0;i<8;i++)
 1024   1      //    {
 1025   1      //        ModBusParam.ChFlow[i] = (WORD)(SysParam.SampFlow[i]);
 1026   1      //        //ModBusParam.ChValve[i] = SysParam.Valve[i];
 1027   1      //    }
 1028   1      //    ModBusParam.SampFlow = SysParam.SampVol;
 1029   1      //    ModBusParam.SampMode = SysParam.SampMode;
 1030   1      //    ModBusParam.SampTime = SysParam.SampTime;
 1031   1      //    ModBusParam.SampVol = SysParam.SampVol;
 1032   1          ModBusParam.RemCtlFlag = SysParam.RemCtlFlag;
 1033   1          ModBusParam.Addr = RemRegAddr.SypAddr;
 1034   1          memset(&ModBusStatus, 0, sizeof(MODBUS_STATUS));
 1035   1      //    ModBusStatus.TotleTime = SysParam.TotleTime;
 1036   1      //    ModBusStatus.TotleVol = SysParam.TotleFlow;
 1037   1      
 1038   1      //    ModBusStatus.SampleFlow = RunStatus.TotleFlow;
 1039   1      //    ModBusStatus.SampleVol = RunStatus.TotleVol;
 1040   1          for(i = 0;i < 8;i++)
 1041   1          {
 1042   2              ModBusStatus.Alarm[i] = GetAlarm(i);
 1043   2          }
 1044   1      
 1045   1      //    ModBusStatus.RemTime = ((DWORD)SysParam.SampTime) * 60 - RunStatus.RunTime;
 1046   1      //    ModBusStatus.RunTime = RunStatus.RunTime;
 1047   1          ModBusStatus.RunStatus = RunStatus.Running;
 1048   1          ModBusStatus.Addr = RemRegAddr.StuAddr;
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 17  

 1049   1      //    for (i=0;i<8;i++)
 1050   1      //    {
 1051   1      //        ModBusStatus.ChFlow[i] = (WORD)(RunStatus.Flow[i]);
 1052   1      //        ModBusStatus.ChVol[i] = (WORD)(RunStatus.Volume[i]);
 1053   1      //    }
 1054   1      
 1055   1          memset(&ModBusInfo, 0, sizeof(MODBUS_INFO));
 1056   1          ModBusInfo.Address = SysParam.Address;
 1057   1          ModBusInfo.Version = VERSION;
 1058   1          ModBusInfo.Addr = RemRegAddr.InfoAddr;
 1059   1          
 1060   1      }
 1061          
 1062          //远程控制读写命令处理
 1063          BYTE SendRemCtlCmd(BYTE Addr, BYTE Cmd, WORD Reg, WORD Count, BYTE * Data)
 1064          {
 1065   1         
 1066   1          WORD i = 0;
 1067   1          WORD crc, SendLen;
 1068   1      
 1069   1          memset(&HostSendFrame, 0, sizeof(HOST_SEND_FRAME));
 1070   1          
 1071   1          HostSendFrame.Address = Addr; 
 1072   1          HostSendFrame.FunctionCode = Cmd;
 1073   1          HostSendFrame.RegAddr = RegSw(Reg);
 1074   1          HostSendFrame.RegCount =  RegSw(Count);
 1075   1      
 1076   1          SendLen = 6;
 1077   1      
 1078   1          if (((Count*2) > 0) && (Data != NULL))
 1079   1          {
 1080   2              HostSendFrame.Data[0] = Count*2;  // 数据长度
 1081   2              SendLen ++;
 1082   2              i++;
 1083   2              memcpy(&HostSendFrame.Data[1], Data, Count*2);
 1084   2              SendLen += Count*2;
 1085   2              i+=2;
 1086   2          }
 1087   1          
 1088   1          // 计算CRC , 并添加到数据后面
 1089   1          crc = CRC16Calc((BYTE *)&HostSendFrame, SendLen);
 1090   1          HostSendFrame.Data[i]  = (BYTE)(crc);
 1091   1          HostSendFrame.Data[i+1] = (BYTE)(crc>>8);
 1092   1          
 1093   1          SendLen += 2; 
 1094   1          Uart4Send((BYTE *)&HostSendFrame, (BYTE)SendLen);
 1095   1      
 1096   1          return true;
 1097   1      }
 1098          
 1099          void FlowTask()
 1100          {
 1101   1          if (RunStatus.Running)
 1102   1          {
 1103   2              if(SendFlowFlag == 1)
 1104   2              {
 1105   3                  SendFlowFlag = 0;
 1106   3                  SendReadFlowCmd(ChNum++);
 1107   3              }
 1108   2              
 1109   2              if (ChNum>9)
 1110   2              {
 1111   3                  ChNum = 1;
 1112   3              }
 1113   2          }
 1114   1      }
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 18  

 1115          
 1116          //远程控制界面切换
 1117          void RemPageCtl()
 1118          {
 1119   1         static BYTE StartRem[5] = {0};
 1120   1         static BYTE RemFlag[5] = {0};
 1121   1      
 1122   1          switch(PageSwitch)
 1123   1          {
 1124   2              case 0:
 1125   2              {
 1126   3                  if(RunStatus.Running)
 1127   3                  {
 1128   4                      if(SysParam.RemCtlFlag)
 1129   4                      {
 1130   5                          if(!RemFlag[4])
 1131   5                          {
 1132   6                              RemFlag[4] = 1;
 1133   6                              StartRem[4]++;
 1134   6                              EnterPage(PAGE_REM);
 1135   6                             
 1136   6                          }
 1137   5                      }
 1138   4                      else
 1139   4                      {
 1140   5                          if(StartRem[4] != 0)
 1141   5                          {
 1142   6                              RemFlag[4]  = 0; 
 1143   6                              SendParam();
 1144   6                              ModeHint(); 
 1145   6                              CheckAlarm();
 1146   6                              EnterPage(PAGE_MAIN);
 1147   6                              StartRem[4] = 0;
 1148   6                          }
 1149   5                      }
 1150   4                  }
 1151   3                  else
 1152   3                  {
 1153   4                       if(SysParam.RemCtlFlag)
 1154   4                      {
 1155   5                          if(!RemFlag[0])
 1156   5                          {
 1157   6                              RemFlag[0] = 1;
 1158   6                              StartRem[0]++;
 1159   6                              EnterPage(PAGE_REM);
 1160   6                             
 1161   6                          }
 1162   5                      }
 1163   4                      else
 1164   4                      {
 1165   5                          if(StartRem[0] != 0)
 1166   5                          {
 1167   6                              RemFlag[0]  = 0; 
 1168   6                              SendParam();
 1169   6                              ModeHint(); 
 1170   6                              EnterPage(PAGE_START);
 1171   6                              StartRem[0] = 0;
 1172   6                          }
 1173   5                      }
 1174   4                      break;
 1175   4                  }
 1176   3              }
 1177   2              
 1178   2              case 1:
 1179   2              {
 1180   3                  if(SysParam.RemCtlFlag)
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 19  

 1181   3                  {
 1182   4                       if(!RemFlag[1])
 1183   4                      {
 1184   5                          RemFlag[1] = 1;
 1185   5                          StartRem[1]++;
 1186   5                          EnterPage(PAGE_REM);
 1187   5                          
 1188   5                       }
 1189   4                  }
 1190   3                  else
 1191   3                  {
 1192   4                       if(StartRem[1] != 0)
 1193   4                      {
 1194   5                          
 1195   5                          RemFlag[1] = 0;
 1196   5                          if(RunStatus.Running)
 1197   5                          {
 1198   6                              SendParam();
 1199   6                              ModeHint(); 
 1200   6                              CheckAlarm();
 1201   6                              EnterPage(PAGE_MAIN);
 1202   6                          }
 1203   5                          else
 1204   5                          {
 1205   6                              SendParam();
 1206   6                              ModeHint(); 
 1207   6                              UpdataUI();
 1208   6                              EnterPage(PAGE_MAIN);
 1209   6                          }
 1210   5                          StartRem[1] = 0;
 1211   5                       }
 1212   4                  }
 1213   3                  break;
 1214   3              }
 1215   2              
 1216   2               case 2:
 1217   2              {
 1218   3                  if(SysParam.RemCtlFlag)
 1219   3                  {
 1220   4                       if(!RemFlag[2])
 1221   4                      {
 1222   5                          RemFlag[2] = 1;
 1223   5                          StartRem[2]++;
 1224   5                          EnterPage(PAGE_REM);
 1225   5                         
 1226   5                       }
 1227   4                  }
 1228   3                  else
 1229   3                  {
 1230   4                       if(StartRem[2] != 0)
 1231   4                      {
 1232   5                          RemFlag[2] = 0;
 1233   5                          SendParam();
 1234   5                          ModeHint(); 
 1235   5                          EnterPage(PAGE_SET);
 1236   5                          StartRem[2] = 0;
 1237   5                       }
 1238   4                  }
 1239   3                  break;
 1240   3              }
 1241   2               
 1242   2               case 3:
 1243   2              {
 1244   3                  if(SysParam.RemCtlFlag)
 1245   3                  {
 1246   4                       if(!RemFlag[3])
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 20  

 1247   4                      {
 1248   5                          RemFlag[3] = 1;
 1249   5                          StartRem[3]++;
 1250   5                          EnterPage(PAGE_REM);
 1251   5                          
 1252   5                       }
 1253   4                  }
 1254   3                  else
 1255   3                  {
 1256   4                       if(StartRem[3] != 0)
 1257   4                      {
 1258   5                          RemFlag[3] = 0;
 1259   5                          SendParam();
 1260   5                          ModeHint(); 
 1261   5                          EnterPage(PAGE_TIME);
 1262   5                          StartRem[3] = 0;
 1263   5                       }
 1264   4                  }
 1265   3                 break; 
 1266   3              }  
 1267   2          }
 1268   1      }
 1269          
 1270          //远程控制向从机写
 1271          void RemCtlWrite()
 1272          {
 1273   1          SendRemCtlCmd(1, CMD_WRITE_REG, MODBUS_PARAM_ADD, 3, (BYTE *)&ModBusParam);
 1274   1          
 1275   1          SendRemCtlCmd(1, CMD_WRITE_REG, MODBUS_STATUS_ADD, 11, (BYTE *)&ModBusStatus);
 1276   1      
 1277   1          SendRemCtlCmd(1, CMD_WRITE_REG, MODBUS_INFO_ADD, 3, (BYTE *)&ModBusInfo);
 1278   1      }
 1279          
 1280          
 1281          //远程控制读从机
 1282          void RemCtlTask()
 1283          {   
 1284   1              WORD RegCnt = 3;
 1285   1              //RemCtlWrite();
 1286   1          Delay(100);
 1287   1      //    if (RunStatus.Running)
 1288   1      //    {
 1289   1               if(RemReadflag == 1)
 1290   1              {
 1291   2                  RemReadflag = 0;
 1292   2      
 1293   2                  SendRemCtlCmd(1, CMD_READ_REG, MODBUS_PARAM_ADD, RegCnt, NULL);
 1294   2      
 1295   2                  SendRemCtlCmd(1, CMD_READ_REG, MODBUS_STATUS_ADD, 11, NULL);
 1296   2      
 1297   2                  SendRemCtlCmd(1, CMD_READ_REG, MODBUS_INFO_ADD, 3, NULL);
 1298   2      
 1299   2      
 1300   2              }
 1301   1          //}
 1302   1      }
 1303          
 1304          void main(void)
 1305          {
 1306   1          BYTE i = 0;
 1307   1          SysInit();
 1308   1          IoInit();
 1309   1          PW_MAIN(1);  // 主电源
 1310   1          LedInit();
 1311   1          
 1312   1          RUN_LED(1);
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 21  

 1313   1         
 1314   1          Delay(200);
 1315   1          
 1316   1          Timer0Init();
 1317   1          Delay(200);
 1318   1          Adc_Init();
 1319   1          Delay(200);
 1320   1          
 1321   1          UART1_config();
 1322   1          UART2_config();
 1323   1          UART3_config();
 1324   1          UART4_config();
 1325   1          ClearUart1Buf();
 1326   1          ClearUart2Buf();
 1327   1          ClearUart3Buf();
 1328   1          ClearUart4Buf();
 1329   1          
 1330   1          // 待CPU稳定了再读参数
 1331   1          Delay(500);
 1332   1          ReadParam();
 1333   1          Delay(200);
 1334   1      
 1335   1          SyncModBusDev();
 1336   1          //RemCtlWrite();
 1337   1          
 1338   1          
 1339   1          RUN_LED(0);
 1340   1      
 1341   1          #if 0
                   while(1)
                   {
                       RUN_LED(0);
                       Delay(800);
                       RUN_LED(1);
                       Delay(200);
                   }
                   #endif
 1350   1          
 1351   1          
 1352   1          EA = 1;     //打开总中断
 1353   1      
 1354   1          WDT_CONTR |= (1<<5) |  7;  // 启动开门狗，约8秒
 1355   1      
 1356   1          Delay(200);
 1357   1          InitLcd();
 1358   1          SysParam.RemCtlFlag = 0;
 1359   1          PageSwitch = 0;
 1360   1          while(1)
 1361   1          {
 1362   2              TimerTask();
 1363   2              HndInput();
 1364   2                   
 1365   2              Uart1Hnd();
 1366   2              Uart2Hnd();
 1367   2              Uart3Hnd();
 1368   2              //RemCtlWrite();
 1369   2              RemPageCtl();
 1370   2              
 1371   2              FlowTask();
 1372   2              
 1373   2              Uart4Hnd();
 1374   2              RemCtlTask();
 1375   2          }
 1376   1      }
 1377          
 1378          
C251 COMPILER V5.60.0,  main                                                               19/10/23  10:22:01  PAGE 22  



Module Information          Static   Overlayable
------------------------------------------------
  code size            =      5272     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       214     ------
  xdata-const size     =    ------     ------
  edata size           =       148     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       256     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
