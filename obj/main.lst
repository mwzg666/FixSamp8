C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\obj\main.obj
COMPILER INVOKED BY: D:\KeilMDK\C251\BIN\C251.EXE main.c XSMALL OPTIMIZE(0,SPEED) BROWSE INCDIR(.\Ads1110;.\Flash;.\mcp4
                    -725;.\IIC;.\MwPro;.\Uart;.\Lcd;.\ModBus;.\Temperaturn) PRINT(.\obj\main.lst) OBJECT(.\obj\main.obj) 

stmt  level    source

    1          #include "main.h"
    2          #include "mcp4725.h"
    3          #include "Lcd.h"
    4          #include "LcdApp.h"
    5          #include "ModBus.h"
    6          #include "Temper.h"
    7          #include "FlowMeter.h"
    8          #include "ModBusDev.h"
    9          #include "ModBusHost.h"
   10          
   11          
   12          BYTE code VERSION = 100;  // V1.0.0
   13          
   14          BYTE xdata StrTmp[64] = {0};
   15          //BYTE xdata Valve[8] = {0};
   16          
   17          BYTE ChannelError[FLOW_METER_CNT] ={0};
   18          
   19          #define Log //((CSampDemoDlg *)theApp.m_pMainWnd)->AddLog
   20          
   21          #define PARAM_SIGN  0x3132
   22          SYS_PARAM xdata SysParam;
   23          RUN_STATUS xdata RunStatus;
   24          REM_REGADDR xdata RemRegAddr;
   25          
   26          float SimFlow = 35.0;
   27          
   28          u16 SendFlowTim = 0;
   29          BYTE SendFlowFlag = 0;
   30          
   31          u16 RemReadTim = 0;     //远程控制读从机开始时间
   32          BYTE RemReadflag = 0;   //远程控制读从机开始标志
   33          //BYTE RemPageflag = 0;
   34          
   35          u16 LcdBusyTim = 0;
   36          BYTE LcdBusyFlag = 0;
   37          BYTE ChNum = 1;
   38          
   39          BYTE g_Output[OUT_IO_COUNT]      = {0,0,0,0,0};   // 上电蓝灯亮 // 
   40          BYTE g_OutStatus[OUT_IO_COUNT]   = {0,0,0,0,0};
   41          
   42          BYTE PageSwitch = 0;                                //远程控制界面选择
   43          //BYTE StartRem[5] = {0,0,0,0,0};
   44          //BYTE RemFlag[5] = {0,0,0,0,0};
   45          
   46          
   47          u16  Timer0Cnt = 0;
   48          
   49          BYTE g_Key_Confrom  = 0; 
   50          BYTE g_Key_Power  = 0; 
   51          BYTE g_Key_Input  = 0; 
   52          BYTE Input_Status = 0;
   53          
   54          WORD gRunTime = 0;
   55          
   56          void DebugMsg(char *msg)
   57          {
   58   1          BYTE len = (BYTE)strlen(msg);
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 2   

   59   1          //Uart1Send((BYTE *)msg,len);
   60   1      }
   61          
   62          void DebugInt(int msg)
   63          {
   64   1          memset(StrTmp,0,64);
   65   1          sprintf(StrTmp,"%x\r\n",msg);
   66   1          DebugMsg(StrTmp);
   67   1      }
   68          
   69          void DumpCmd(BYTE *dat, BYTE len)
   70          {
   71   1          BYTE i;
   72   1          memset(StrTmp,0,64);
   73   1          for (i=0;i<len;i++)
   74   1          {
   75   2              if (strlen(StrTmp) >= 60)
   76   2              {
   77   3                  break;
   78   3              }
   79   2              sprintf(&StrTmp[i*3], "%02X ", dat[i]);
   80   2          }
   81   1          sprintf(&StrTmp[i*3], "\r\n");
   82   1          DebugMsg(StrTmp);
   83   1      }
   84          
   85          
   86          void Error()
   87          {
   88   1          while(1)
   89   1          {
   90   2              RUN_LED(1);
   91   2              Delay(50);
   92   2              RUN_LED(0);
   93   2              Delay(50);
   94   2          }
   95   1          
   96   1      }
   97          
   98          
   99          void SysInit()
  100          {
  101   1          HIRCCR = 0x80;           // 启动内部高速IRC
  102   1          while(!(HIRCCR & 1));
  103   1          CLKSEL = 0;              
  104   1      }
  105          
  106          void IoInit()
  107          {
  108   1          EAXFR = 1;
  109   1          WTST = 0;   //设置程序指令延时参数，赋值为0可将CPU执行指令的速度设置为最快
  110   1      
  111   1          P0M1 = 0x00;   P0M0 |= (1<<4) ;                     // P0.0 P0.1 P0.4 推挽输出
  112   1          P1M1 = (1<<4)|(1<<3);   P1M0 = 0x00;                       //设置为准双向口
  113   1          P2M1 = 0x00;   P2M0 |= 0x00;                      // P2.2 推挽输出
  114   1          P3M1 = 0x00;   P3M0 |= (1<<2)|(1<<3)|(1<<4);        //设置为准双向口
  115   1          P4M1 = 0x00;   P4M0 = 0x00;                       //设置为准双向口
  116   1          P5M1 = 0x00;   P5M0 |= (1<<0) | (1<<2);             //设置为准双向口
  117   1          P6M1 = 0x00;   P6M0 |= (1<<7);     //设置为准双向口
  118   1          P7M1 = 0x00;   P7M0 = 0x00;                         //设置为准双向口
  119   1      }
  120          
  121          
  122          void SensorInit()
  123          {
  124   1          // P1.0 -- 下降缘中断
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 3   

  125   1          P1IM0 = 0;
  126   1          P1IM1 = 0;
  127   1      
  128   1          // 优先级2
  129   1          //PIN_IP  |= (1<<1);
  130   1          PINIPH |= (1<<1);
  131   1          //P1_IP  = 1; // |= (1<<1);
  132   1          //P1_IPH = 1; //|= (1<<1);
  133   1      
  134   1          // 允许中断
  135   1          P1INTE |= (1<<0) | (1<<1) | (1<<4) | (1<<5);
  136   1      }
  137          
  138          
  139          
  140          void Timer0Init()
  141          {
  142   1          AUXR = 0x00;    //Timer0 set as 12T, 16 bits timer auto-reload, 
  143   1          TH0 = (u8)(Timer0_Reload / 256);
  144   1          TL0 = (u8)(Timer0_Reload % 256);
  145   1          ET0 = 1;    //Timer0 interrupt enable
  146   1          TR0 = 1;    //Tiner0 run
  147   1          
  148   1          // 中断优先级3
  149   1          PT0  = 0;
  150   1          PT0H = 0;
  151   1      }
  152          
  153          // 10ms 中断一下
  154          void Timer0Int (void) interrupt 1
  155          {
  156   1          Timer0Cnt ++;
  157   1      }
  158          
  159          #if 0
               // 公用中断服务程序
               void CommInt (void) interrupt 13
               {
                   u8 intf =  P1INTF;
                   
                   if (intf)
                   {
                       P1INTF = 0;
               
                       if (intf & (1<<0))  // P1.0 中断
                       {
                           Counter[0] ++;
                       }
               
                       if (intf & (1<<1))  // P1.1 中断
                       {
                           Counter[1] ++;
                       }
               
                       if (intf & (1<<4))  // P1.4 中断
                       {
                           Counter[2] ++;
                       }
               
                       if (intf & (1<<5))  // P1.5 中断
                       {
                           Counter[3] ++;
                       }
                   }
                   
               }
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 4   

               #endif
  192          
  193          
  194          void OutCtl(alt_u8 id, alt_u8 st)
  195          {
  196   1          if (g_OutStatus[id] == st)
  197   1          {
  198   2              return;
  199   2          }
  200   1      
  201   1          g_OutStatus[id] = st;
  202   1          
  203   1          switch(id)
  204   1          {   
  205   2              case LIGHT_BLUE: 
  206   2              {
  207   3                  (st)? BLU_LIGHT(1) : BLU_LIGHT(0); 
  208   3                  break;
  209   3              }
  210   2          
  211   2              case LIGHT_YELLOW: 
  212   2              {
  213   3                  (st)? YEL_LIGHT(1):YEL_LIGHT(0);
  214   3                  break;
  215   3              }
  216   2      
  217   2              case GAS_BUMP:      //泵
  218   2              {
  219   3                  (st)? BUMP_M(1) : BUMP_M(0);
  220   3                  break;
  221   3              }
  222   2      
  223   2              case EX_FAN:        //风扇
  224   2              {
  225   3                  (st)? FANS_M(1) : FANS_M(0);
  226   3                  break;
  227   3              }
  228   2      
  229   2              case ALARM_SOUND:   //报警
  230   2              {
  231   3                  (st)? ALARM(1) : ALARM(0);       
  232   3                  break;
  233   3              }
  234   2          }
  235   1      
  236   1          
  237   1      }
  238          
  239          void OutFlash(alt_u8 id)
  240          {
  241   1          static alt_u16 OutTimer[OUT_IO_COUNT] = {0,0,0,0,0};
  242   1          if (OutTimer[id] ++ > LED_FLASH_TIME/10)
  243   1          {
  244   2              OutTimer[id] = 0;
  245   2              if (g_OutStatus[id] == 1)
  246   2              {
  247   3                  OutCtl(id, 0);
  248   3              }
  249   2              else
  250   2              {
  251   3                  OutCtl(id, 1);
  252   3              }
  253   2          }
  254   1      }
  255          
  256          void IoCtlTask()
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 5   

  257          {
  258   1          alt_u8 i;
  259   1          for (i=0;i<OUT_IO_COUNT;i++)
  260   1          {
  261   2              if (g_Output[i] == 2)
  262   2              {
  263   3                  OutFlash(i);
  264   3              }
  265   2              else
  266   2              {
  267   3                  OutCtl(i, g_Output[i]);
  268   3              }
  269   2          }
  270   1      }
  271          
  272          // 板载指示灯
  273          void RunLed(u16 dt)
  274          {   
  275   1          static u16 tm = 0;
  276   1          u16 to = 3000;
  277   1          tm += dt;
  278   1      
  279   1          if (tm > to)
  280   1          {
  281   2              tm = 0;
  282   2              RUN_LED(0);
  283   2          }
  284   1          else if (tm > (to-100))
  285   1          {
  286   2              RUN_LED(1);
  287   2          }
  288   1      }
  289          
  290          
  291          
  292          void Task1s()
  293          {
  294   1          static BYTE tm = 0;
  295   1      
  296   1          CLR_WDT = 1;  // 喂狗
  297   1          tm++;
  298   1          if(tm == 10)
  299   1          {
  300   2              ADC_Temp();
  301   2              SyncModBusDev();
  302   2              tm = 0;
  303   2          } 
  304   1          
  305   1          if((tm == 6)||(tm == 3))
  306   1          {
  307   2              GetRetCode();
  308   2          }
  309   1          
  310   1          if(tm == 9)
  311   1          {
  312   2              if (RunStatus.Running)
  313   2              {  
  314   3                  DevRun();
  315   3              }
  316   2          }
  317   1      }
  318          
  319          
  320          void TimerTask()
  321          {
  322   1          u16 delta = 0;
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 6   

  323   1          static u16 Time1s = 0;
  324   1          
  325   1          if (Timer0Cnt)
  326   1          {
  327   2              delta = Timer0Cnt * 10;
  328   2              Timer0Cnt = 0;
  329   2      
  330   2              if (RX2_Cnt > 0)
  331   2              {
  332   3                  Rx2_Timer += delta;
  333   3              }
  334   2      
  335   2              if(RX3_Cnt > 0)
  336   2              {
  337   3                  Rx3_Timer += delta;
  338   3              }
  339   2              
  340   2              if(RX4_Cnt > 0)
  341   2              {
  342   3                  Rx4_Timer += delta;
  343   3              }
  344   2              
  345   2              SendFlowTim += delta;
  346   2              if(SendFlowTim > 220)
  347   2              {
  348   3                  SendFlowTim = 0;
  349   3                  SendFlowFlag = 1;
  350   3              }
  351   2      
  352   2              RemReadTim += delta;
  353   2              if(RemReadTim > 250)
  354   2              {
  355   3                  RemReadTim = 0;
  356   3                  RemReadflag = 1;
  357   3              }
  358   2      
  359   2              if (gRunTime < 5000)
  360   2              {
  361   3                  gRunTime += delta;
  362   3              }
  363   2      
  364   2              //if (g_CommIdleTime < 300)
  365   2              //{
  366   2                  //g_CommIdleTime += delta;
  367   2              //}
  368   2      
  369   2              #ifdef IRDA_FUN
                       if (IrDAStart == 1)
                       {
                           IrDATimer += delta;
                       }
                       #endif
  375   2      
  376   2              Time1s += delta;
  377   2              if (Time1s >= 100)
  378   2              {
  379   3                  Time1s = 0;
  380   3                  Task1s();
  381   3              }
  382   2              RunLed(delta);
  383   2              IoCtlTask();
  384   2              GetValve();
  385   2              ShowRemCh();
  386   2          }
  387   1      }
  388          
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 7   

  389          
  390          
  391          void Delay(WORD ms)
  392          {
  393   1          WORD t = 1000;
  394   1          while(ms--)
  395   1          {
  396   2              for (t=0;t<1000;t++) ;
  397   2          }
  398   1      }
  399          
  400          
  401          WORD ParamCheck(BYTE *buf, WORD len)
  402          {
  403   1          WORD dwSum = 0;
  404   1          WORD i;
  405   1      
  406   1          for (i = 0; i < len; i++)
  407   1          {
  408   2              dwSum += buf[i];
  409   2          }
  410   1      
  411   1          return dwSum;
  412   1      }
  413          
  414          /*
  415          void DefSenParam()
  416          {
  417              BYTE i;
  418              for (i=0; i<SENSOR_COUNT; i++)
  419              {
  420                  SysParam.SenParam[i].LOW_REVISE_COE_A = 1;
  421                  SysParam.SenParam[i].LOW_REVISE_COE_B = 1;
  422                  SysParam.SenParam[i].LOW_REVISE_COE_C = 1;
  423          
  424                  SysParam.SenParam[i].HIG_REVISE_COE_A = 1;
  425                  SysParam.SenParam[i].HIG_REVISE_COE_B = 1;
  426                  SysParam.SenParam[i].HIG_REVISE_COE_C = 1;
  427          
  428                  SysParam.SenParam[i].SUPER_REVISE_COE_A = 1;
  429                  SysParam.SenParam[i].SUPER_REVISE_COE_B = 1;
  430                  SysParam.SenParam[i].SUPER_REVISE_COE_C = 1;
  431          
  432                  SysParam.SenParam[i].DET_THR_1 = 500;
  433                  SysParam.SenParam[i].DET_THR_2 = 150;
  434                  SysParam.SenParam[i].DET_THR_3 = 150;
  435          
  436                  SysParam.SenParam[i].DET_TIME = 1000;
  437                  SysParam.SenParam[i].HV_THR = 1000;
  438              }
  439          }
  440          */
  441          
  442          /*
  443          void DefSenAlarm()
  444          {
  445              BYTE i;
  446              for (i=0; i<SENSOR_COUNT; i++)
  447              {
  448                  SysParam.AlmParam[i].DOSE_RATE_ALARM_1 = 300;
  449                  SysParam.AlmParam[i].DOSE_RATE_ALARM_2 = 400;
  450                  SysParam.AlmParam[i].CUM_DOSE_RATE_ALARM_1 = 300;
  451                  SysParam.AlmParam[i].CUM_DOSE_RATE_ALARM_2 = 400;
  452                  SysParam.AlmParam[i].INVALID_ALRAM_1 = 8000;
  453                  SysParam.AlmParam[i].INVALID_ALRAM_2 = 10000;
  454              }
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 8   

  455          }
  456          */
  457          
  458          void ReadParam()
  459          {
  460   1          EEPROM_read(0, (BYTE *)&SysParam, sizeof(SYS_PARAM));
  461   1      
  462   1          #if 0
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(SYS_PARAM));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(HOST_SENSOR_PARAM));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(HOST_ALRAM_PARA));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(float));
                   DebugMsg((char *)StrTmp);
                   
                   //Rs485Send((BYTE *)&SysParam, sizeof(SYS_PARAM));
                   
                   
                   if (SysParam.Sign != PARAM_SIGN)
                   {
                       DebugMsg("Sign error. \r\n");
                   }
               
                   if (SysParam.Sum != ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2))
                   {
                       DebugMsg("Param Check error. \r\n");
                   }
                   #endif
  492   1      
  493   1         
  494   1          if ( (SysParam.Sign != PARAM_SIGN) ||
  495   1               (SysParam.Sum != ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2)) )
  496   1          {
  497   2              //SysParam.Sign = PARAM_SIGN;
  498   2              //SysParam.Address = 1;
  499   2              ParamDef();
  500   2              //DefSenParam();
  501   2              //DefSenAlarm();
  502   2              WriteParam();
  503   2      
  504   2              //DebugMsg("Def Param. \r\n");
  505   2          }
  506   1      }
  507          
  508          
  509          void WriteParam()
  510          {
  511   1          EA = 0;    
  512   1          
  513   1          EEPROM_SectorErase(0);
  514   1          EEPROM_SectorErase(512);
  515   1          SysParam.Sum = ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2);
  516   1          if (!EEPROM_write(0, (BYTE *)&SysParam, sizeof(SYS_PARAM)))
  517   1          {
  518   2              Error();
  519   2          }
  520   1      
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 9   

  521   1          EA = 1;     //打开总中断
  522   1      }
  523          
  524          BYTE GetInput()
  525          {
  526   1          // 当前只有一个开关机状态 P2.1
  527   1          static BYTE his = LOCK_BIT();
  528   1          BYTE st = POWER_LOCK();
  529   1      
  530   1          if (st != his)
  531   1          {
  532   2              Delay(50);
  533   2              if ( st == POWER_LOCK() )
  534   2              {
  535   3                  his = st;
  536   3                  return st;
  537   3              }
  538   2          }
  539   1      
  540   1          return 0xFF;
  541   1      }
  542          
  543          
  544          void PowerOff()
  545          {
  546   1          PW_MAIN(0);
  547   1      
  548   1          while(1)
  549   1          {
  550   2              ;
  551   2          }
  552   1      }
  553          
  554          void HndInput()
  555          {
  556   1          static bool em = false;
  557   1          if(STOP_M() == 0)
  558   1          {
  559   2              Delay(10);
  560   2              if (STOP_M() == 0)
  561   2              {
  562   3                  if (RunStatus.Running)
  563   3                  {
  564   4                      StopSamp(false);
  565   4                  }
  566   3              }
  567   2      
  568   2              if (em == false)
  569   2              {
  570   3                  em = true;
  571   3                  ShowEmStop(em);
  572   3              }
  573   2          }
  574   1          else
  575   1          {
  576   2              if (em)
  577   2              {
  578   3                  em = false;
  579   3                  ShowEmStop(em);
  580   3              }
  581   2          }
  582   1      }
  583          
  584          /*
  585          void ReportInput()
  586          {
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 10  

  587              BYTE PwOff = POWER_OFF;
  588              
  589              if (g_CommIdleTime > 200)
  590              {
  591                  if (g_Key_Confrom)
  592                  {
  593                      g_Key_Confrom = 0;
  594                      SendPcCmd(0, CMD_CERTAINKEY, NULL, 0);
  595                      return;
  596                  }
  597          
  598                  if (g_Key_Power)
  599                  {
  600                      g_Key_Power = 0;
  601                      SendPcCmd(0, CMD_POWER, &PwOff, 1);
  602                      return;
  603                  }
  604          
  605                  #if 0
  606                  if (g_Key_Input)
  607                  {
  608                      g_Key_Input = 0;
  609                      SendPcCmd(0, CMD_INPUT, &Input_Status, 1);
  610                  }
  611                  #endif
  612              }
  613          }
  614          */
  615          
  616          void LedInit()
  617          {
  618   1          // 初始状态都为0
  619   1      
  620   1          // 指示灯
  621   1          YEL_LIGHT(0);   // 黄灯
  622   1          BLU_LIGHT(0);   // 蓝灯
  623   1          
  624   1          CloseValve();   // 电磁阀
  625   1          BUMP_M(0);      // 泵
  626   1          FANS_M(0);      // 风扇
  627   1          ALARM(0);       // 报警音
  628   1      }
  629          
  630          
  631          void ParamDef()
  632          {
  633   1          BYTE i;
  634   1          
  635   1          SysParam.Sign     = PARAM_SIGN;
  636   1          SysParam.Address = 1;
  637   1          SysParam.BkLight = 50;
  638   1      
  639   1          SysParam.SampMode = MODE_TIME;
  640   1          SysParam.SampTime = 5;  
  641   1          SysParam.SampVol   = 2;
  642   1          SysParam.AlarmThres   = 10;
  643   1          for (i=0;i<CHANNLE_NUM;i++)
  644   1          {
  645   2              SysParam.SampFlow[i] = 35;
  646   2              //SysParam.Valve[i] = 0;
  647   2          }
  648   1      
  649   1          SysParam.Enable = 0x1F;
  650   1          SysParam.RemCtlFlag = false;
  651   1      
  652   1          RemRegAddr.SypAddr = MODBUS_PARAM_ADD;
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 11  

  653   1          RemRegAddr.StuAddr = MODBUS_STATUS_ADD;
  654   1          RemRegAddr.InfoAddr = MODBUS_INFO_ADD;
  655   1      }
  656          
  657          void SaveParam()
  658          {
  659   1          //CString t;
  660   1          //t.Format(_T("SaveParam: %02X\r\n"), SysParam.Enable);
  661   1          //Log(t);
  662   1          //DebugMsg("123");
  663   1          WriteParam();
  664   1      }
  665          
  666          
  667          void UpdataUI()
  668          {
  669   1          BYTE i;
  670   1          for (i=0;i<CHANNLE_NUM;i++)
  671   1          {
  672   2              ChannelAlarm[i] = ((SysParam.Enable & (1<<i)) == 0)?0:1;
  673   2          }
  674   1          ShowStatus();
  675   1          Delay(200);
  676   1          StatusColor(true);
  677   1      }
  678          
  679          void InitLcd()
  680          {   
  681   1          memset(&RunStatus, 0, sizeof(RUN_STATUS));
  682   1          memset(&RunInfo, 0, sizeof(RUN_INFO));
  683   1          memset(&RealFlow, 0, sizeof(RealFlow));
  684   1          
  685   1          //ParamDef();
  686   1          ModeHint();
  687   1          Delay(200);
  688   1          HideModule(MP_HINT_END);
  689   1          Delay(200);
  690   1          UpdataUI();    
  691   1          Delay(200);
  692   1          SendParam();
  693   1          Delay(200);
  694   1          SetBkLight(false);
  695   1          Delay(200);
  696   1          ShowDevInfo();
  697   1          Delay(200);
  698   1      }
  699          
  700          
  701          void GetFlow()
  702          {
  703   1          BYTE i;
  704   1          WORD  w;
  705   1          DWORD d;
  706   1      
  707   1          
  708   1          for (i=0;i<CHANNLE_NUM;i++)
  709   1          {
  710   2              if (SysParam.Enable & (1<<i))
  711   2              {
  712   3                  RunStatus.Flow[i] = RealFlow[i].val;  // 模拟 -- 实际要从流量计中读取
  713   3                  w = (WORD)(RunStatus.Flow[i]*10);
  714   3                  RunInfo.ChFlow[i].Flow = SwWord(w);
  715   3                  
  716   3                  RunStatus.Volume[i] =  RealFlow[i].Totol; 
  717   3                  w = (WORD)(RunStatus.Volume[i]*10);
  718   3                  RunInfo.ChFlow[i].Vol = SwWord(w);
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 12  

  719   3              }
  720   2          }
  721   1      
  722   1          // 总流量
  723   1          RunStatus.TotleFlow = RealFlow[8].val;
  724   1          d = (DWORD)(RealFlow[8].val*10);
  725   1          RunInfo.TotFlow.Flow = SwDWord(d);
  726   1      
  727   1          // 总体积
  728   1          RunStatus.TotleVol = RealFlow[8].Totol;
  729   1          d = (DWORD)(RealFlow[8].Totol*10);
  730   1          RunInfo.TotFlow.Vol   = SwDWord(d);
  731   1      }
  732          
  733          void StartSamp()
  734          {
  735   1          memset(&RunStatus, 0, sizeof(RUN_STATUS));
  736   1          memset(&RunInfo, 0, sizeof(RUN_INFO));
  737   1          memset(&RealFlow, 0, sizeof(RealFlow));
  738   1          
  739   1          RunStatus.Running = true;
  740   1          g_Output[LIGHT_BLUE] = 1;
  741   1          CheckValve();
  742   1          OpenPump();
  743   1          SetStartBtn(0);
  744   1      
  745   1      }
  746          
  747          void StopSamp(bool Auto)
  748          {
  749   1          ClosePump();
  750   1          memset(RealFlow,0, sizeof(RealFlow));
  751   1      
  752   1          RunStatus.Running = false;
  753   1          g_Output[LIGHT_BLUE] = 0;
  754   1          
  755   1          SetStartBtn(1);  // 按钮自动变为“开始”
  756   1          
  757   1          if (Auto)  // 自动结束
  758   1          {
  759   2              // 显示取样结束提示框
  760   2              ShowModule(MP_HINT_END, REG_HINT_END);
  761   2          }
  762   1      }
  763          
  764          // 定时模式
  765          void TimingMode()
  766          {
  767   1          if (RunStatus.RunTime >= ((DWORD)SysParam.SampTime) * 60)
  768   1          {
  769   2              StopSamp(true);
  770   2          }
  771   1      }
  772          
  773          
  774          // 定量模式
  775          void VolumeMode()
  776          {
  777   1          if (RunStatus.TotleVol >= SysParam.SampVol)
  778   1          {
  779   2              StopSamp(true);
  780   2          }
  781   1      }
  782          
  783          
  784          void RunCheck()
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 13  

  785          {
  786   1          switch (SysParam.SampMode)
  787   1          {
  788   2              case MODE_TIME:  TimingMode();  break;
  789   2              case MODE_VOL:   VolumeMode();  break;
  790   2          }
  791   1      }
  792          
  793          void AbnorAlaerm()
  794          {   
  795   1          BYTE i;
  796   1          bool HaveAlarm = false;
  797   1      
  798   1          
  799   1          
  800   1          for(i = 0;i < CHANNLE_NUM;i++)
  801   1          {
  802   2              if( (ChannelAlarm[i] == ALM_FLOW_ABNOR) ||
  803   2                  (ChannelAlarm[i] ==  ALM_FLOW_LOW) || 
  804   2                  (ChannelAlarm[i] == ALM_FLOW_HIGH)  )
  805   2              {
  806   3                  HaveAlarm = true;
  807   3                  break;
  808   3              }
  809   2          }
  810   1      
  811   1          if (HaveAlarm)
  812   1          {
  813   2              g_Output[LIGHT_YELLOW] = 1;
  814   2              g_Output[ALARM_SOUND] = 2;
  815   2          }
  816   1          else
  817   1          {
  818   2              g_Output[LIGHT_YELLOW] = 0;
  819   2              g_Output[ALARM_SOUND] = 0;
  820   2          }
  821   1      }
  822          void CheckAlarm()
  823          {
  824   1          BYTE i;
  825   1          float flow;
  826   1          
  827   1          for (i=0;i<CHANNLE_NUM;i++)
  828   1          {
  829   2              if (SysParam.Enable & (1<<i))
  830   2              {
  831   3                  flow = RunStatus.Flow[i];
  832   3                  if (flow > SysParam.SampFlow[i]*(100+SysParam.AlarmThres)/100)
  833   3                  {
  834   4                      ChannelAlarm[i] = ALM_FLOW_HIGH;
  835   4                  }
  836   3                  else if (flow < SysParam.SampFlow[i]*(100-SysParam.AlarmThres)/100)
  837   3                  {
  838   4                      ChannelAlarm[i] = ALM_FLOW_LOW;
  839   4                  }
  840   3                  else
  841   3                  {
  842   4                      ChannelAlarm[i] = ALM_FLOW_NOR;
  843   4                  }
  844   3              }
  845   2              else
  846   2              {
  847   3                  ChannelAlarm[i] = ALM_CH_DISABLE;
  848   3              }
  849   2              
  850   2              if( (ChannelError[i] > 3) && (ChannelAlarm[i] != ALM_CH_DISABLE) )
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 14  

  851   2              {
  852   3                  ChannelAlarm[i] = ALM_FLOW_ABNOR;
  853   3              }
  854   2          }
  855   1      
  856   1          if (memcmp(HisAlarm,ChannelAlarm,CHANNLE_NUM) != 0)
  857   1          {
  858   2              // 报警有变化才更新界面
  859   2              Delay(200);
  860   2              ShowStatus();
  861   2              Delay(200);
  862   2              AbnorAlaerm();
  863   2              StatusColor(false);
  864   2      
  865   2              memcpy(HisAlarm,ChannelAlarm,8);
  866   2          }
  867   1      }
  868          
  869          // 1秒运行一次
  870          void DevRun()
  871          {
  872   1          RunStatus.RunTime ++;
  873   1          
  874   1          // 1. 获取流量
  875   1          GetFlow();
  876   1      
  877   1          // 2. 显示流量和状态
  878   1          ShowFlow();
  879   1          //Delay(200);
  880   1          
  881   1          // 3. 检查报警状态  
  882   1          if (RunStatus.RunTime > 10)
  883   1          {
  884   2              // 运行时间大于10秒才检测
  885   2              CheckAlarm();
  886   2          }
  887   1          
  888   1          // 4. 根据模式判断是否结束取样
  889   1          RunCheck();
  890   1      }
  891          
  892          
  893          //获取电磁阀状态
  894          void GetValve()
  895          {
  896   1          BYTE i;
  897   1          for(i = 0;i<CHANNLE_NUM;i++)
  898   1          {
  899   2              if(SysParam.Enable & (1<<i))
  900   2              {
  901   3                  RemChStatus[i] = 1;
  902   3                 //SysParam.Valve[i] = 1;
  903   3              }
  904   2              else
  905   2              {
  906   3                  RemChStatus[i] = 0;
  907   3      //           SysParam.Valve[i] = 0;
  908   3              }
  909   2          }
  910   1      
  911   1      }
  912          
  913          //查询电磁阀状态
  914          void CheckValve()
  915          {
  916   1          BYTE i;
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 15  

  917   1          for(i = 0;i<CHANNLE_NUM;i++)
  918   1          {
  919   2              if(RemChStatus[i])//(SysParam.Valve[i])
  920   2              {
  921   3                  switch(i)
  922   3                  {
  923   4                      case 0 : VALVE0(1); break;
  924   4                      case 1 : VALVE1(1); break;
  925   4                      case 2 : VALVE2(1); break;
  926   4                      case 3 : VALVE3(1); break;
  927   4                      case 4 : VALVE4(1); break;
  928   4                      case 5 : VALVE5(1); break;
  929   4                      case 6 : VALVE6(1); break;
  930   4                      case 7 : VALVE7(1); break;  
  931   4                  }
  932   3              }
  933   2              else
  934   2              {
  935   3                  switch(i)
  936   3                  {
  937   4                      case 0 : VALVE0(0); break;
  938   4                      case 1 : VALVE1(0); break;
  939   4                      case 2 : VALVE2(0); break;
  940   4                      case 3 : VALVE3(0); break;
  941   4                      case 4 : VALVE4(0); break;
  942   4                      case 5 : VALVE5(0); break;
  943   4                      case 6 : VALVE6(0); break;
  944   4                      case 7 : VALVE7(0); break;  
  945   4                  }
  946   3              }
  947   2          }
  948   1          Delay(20);
  949   1      }
  950          
  951          //关闭电磁阀
  952          void CloseValve()
  953          {
  954   1          VALVE0(0);
  955   1          VALVE1(0);
  956   1          VALVE2(0);
  957   1          VALVE3(0);
  958   1          VALVE4(0);
  959   1          VALVE5(0);
  960   1          VALVE6(0);
  961   1          VALVE7(0);
  962   1          Delay(20);
  963   1      }
  964          // 开启气泵
  965          void OpenPump()
  966          {
  967   1          //BUMP_M(1);
  968   1          g_Output[GAS_BUMP] = 1;
  969   1      }
  970          
  971          
  972          // 停止气泵
  973          void ClosePump()
  974          {
  975   1          //BUMP_M(0);
  976   1          CloseValve();
  977   1          g_Output[GAS_BUMP] = 0;
  978   1      }
  979          
  980          void SendReadFlowCmd(BYTE ch)
  981          {
  982   1          ChannelError[ch-1] ++;
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 16  

  983   1          SendReadFlow(ch);    
  984   1      }
  985          
  986          WORD GetAlarm(BYTE i)
  987          {
  988   1          //BYTE i;
  989   1      
  990   1      //    for (i=0;i<8;i++)
  991   1      //    {
  992   1              if(ChannelAlarm[i] == ALM_CH_DISABLE)
  993   1              {
  994   2                  return ALM_CH_DISABLE;
  995   2              }
  996   1              if (ChannelAlarm[i] ==  ALM_FLOW_ABNOR)
  997   1              {
  998   2                  return ALM_FLOW_ABNOR;
  999   2              }
 1000   1              
 1001   1              if (ChannelAlarm[i] ==  ALM_FLOW_HIGH)
 1002   1              {
 1003   2                  return ALM_FLOW_HIGH;
 1004   2              }
 1005   1      
 1006   1              if (ChannelAlarm[i] ==  ALM_FLOW_LOW)
 1007   1              {
 1008   2                  return ALM_FLOW_LOW;
 1009   2              }
 1010   1          //}
 1011   1      
 1012   1          return ALM_FLOW_NOR;
 1013   1      }
 1014          
 1015          void SyncModBusDev()
 1016          {
 1017   1          BYTE i;
 1018   1          memset(&ModBusParam, 0, sizeof(MODBUS_PARAM));
 1019   1          //ModBusParam.AlamrThres = SysParam.AlarmThres;
 1020   1          ModBusParam.ChEnable =   SysParam.Enable;
 1021   1      
 1022   1      //    for (i=0;i<8;i++)
 1023   1      //    {
 1024   1      //        ModBusParam.ChFlow[i] = (WORD)(SysParam.SampFlow[i]);
 1025   1      //        //ModBusParam.ChValve[i] = SysParam.Valve[i];
 1026   1      //    }
 1027   1      //    ModBusParam.SampFlow = SysParam.SampVol;
 1028   1      //    ModBusParam.SampMode = SysParam.SampMode;
 1029   1      //    ModBusParam.SampTime = SysParam.SampTime;
 1030   1      //    ModBusParam.SampVol = SysParam.SampVol;
 1031   1          ModBusParam.RemCtlFlag = SysParam.RemCtlFlag;
 1032   1          ModBusParam.Addr = RemRegAddr.SypAddr;
 1033   1          memset(&ModBusStatus, 0, sizeof(MODBUS_STATUS));
 1034   1      //    ModBusStatus.TotleTime = SysParam.TotleTime;
 1035   1      //    ModBusStatus.TotleVol = SysParam.TotleFlow;
 1036   1      
 1037   1      //    ModBusStatus.SampleFlow = RunStatus.TotleFlow;
 1038   1      //    ModBusStatus.SampleVol = RunStatus.TotleVol;
 1039   1          for(i = 0;i < 8;i++)
 1040   1          {
 1041   2              ModBusStatus.Alarm[i] = GetAlarm(i);
 1042   2          }
 1043   1      
 1044   1      //    ModBusStatus.RemTime = ((DWORD)SysParam.SampTime) * 60 - RunStatus.RunTime;
 1045   1      //    ModBusStatus.RunTime = RunStatus.RunTime;
 1046   1          ModBusStatus.RunStatus = RunStatus.Running;
 1047   1          ModBusStatus.Addr = RemRegAddr.StuAddr;
 1048   1      //    for (i=0;i<8;i++)
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 17  

 1049   1      //    {
 1050   1      //        ModBusStatus.ChFlow[i] = (WORD)(RunStatus.Flow[i]);
 1051   1      //        ModBusStatus.ChVol[i] = (WORD)(RunStatus.Volume[i]);
 1052   1      //    }
 1053   1      
 1054   1          memset(&ModBusInfo, 0, sizeof(MODBUS_INFO));
 1055   1          ModBusInfo.Address = SysParam.Address;
 1056   1          ModBusInfo.Version = VERSION;
 1057   1          ModBusInfo.Addr = RemRegAddr.InfoAddr;
 1058   1          
 1059   1      }
 1060          
 1061          //远程控制读写命令处理
 1062          BYTE SendRemCtlCmd(BYTE Addr, BYTE Cmd, WORD Reg, WORD Count, BYTE * Data)
 1063          {
 1064   1         
 1065   1          WORD i = 0;
 1066   1          WORD crc, SendLen;
 1067   1      
 1068   1          memset(&HostSendFrame, 0, sizeof(HOST_SEND_FRAME));
 1069   1          
 1070   1          HostSendFrame.Address = Addr; 
 1071   1          HostSendFrame.FunctionCode = Cmd;
 1072   1          HostSendFrame.RegAddr = RegSw(Reg);
 1073   1          HostSendFrame.RegCount =  RegSw(Count);
 1074   1      
 1075   1          SendLen = 6;
 1076   1      
 1077   1          if (((Count*2) > 0) && (Data != NULL))
 1078   1          {
 1079   2              HostSendFrame.Data[0] = Count*2;  // 数据长度
 1080   2              SendLen ++;
 1081   2              i++;
 1082   2              memcpy(&HostSendFrame.Data[1], Data, Count*2);
 1083   2              SendLen += Count*2;
 1084   2              i+=2;
 1085   2          }
 1086   1          
 1087   1          // 计算CRC , 并添加到数据后面
 1088   1          crc = CRC16Calc((BYTE *)&HostSendFrame, SendLen);
 1089   1          HostSendFrame.Data[i]  = (BYTE)(crc);
 1090   1          HostSendFrame.Data[i+1] = (BYTE)(crc>>8);
 1091   1          
 1092   1          SendLen += 2; 
 1093   1          Uart4Send((BYTE *)&HostSendFrame, (BYTE)SendLen);
 1094   1      
 1095   1          return true;
 1096   1      }
 1097          
 1098          void FlowTask()
 1099          {
 1100   1          if (RunStatus.Running)
 1101   1          {
 1102   2              if(SendFlowFlag == 1)
 1103   2              {
 1104   3                  SendFlowFlag = 0;
 1105   3                  SendReadFlowCmd(ChNum++);
 1106   3              }
 1107   2              
 1108   2              if (ChNum>9)
 1109   2              {
 1110   3                  ChNum = 1;
 1111   3              }
 1112   2          }
 1113   1      }
 1114          
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 18  

 1115          //远程控制界面切换
 1116          void RemPageCtl()
 1117          {
 1118   1         static BYTE StartRem[5] = {0};
 1119   1         static BYTE RemFlag[5] = {0};
 1120   1      
 1121   1          switch(PageSwitch)
 1122   1          {
 1123   2              case 0:
 1124   2              {
 1125   3                  if(RunStatus.Running)
 1126   3                  {
 1127   4                      if(SysParam.RemCtlFlag)
 1128   4                      {
 1129   5                          if(!RemFlag[4])
 1130   5                          {
 1131   6                              RemFlag[4] = 1;
 1132   6                              StartRem[4]++;
 1133   6                              EnterPage(PAGE_REM);
 1134   6                             
 1135   6                          }
 1136   5                      }
 1137   4                      else
 1138   4                      {
 1139   5                          if(StartRem[4] != 0)
 1140   5                          {
 1141   6                              RemFlag[4]  = 0; 
 1142   6                              SendParam();
 1143   6                              ModeHint(); 
 1144   6                              CheckAlarm();
 1145   6                              EnterPage(PAGE_MAIN);
 1146   6                              StartRem[4] = 0;
 1147   6                          }
 1148   5                      }
 1149   4                  }
 1150   3                  else
 1151   3                  {
 1152   4                       if(SysParam.RemCtlFlag)
 1153   4                      {
 1154   5                          if(!RemFlag[0])
 1155   5                          {
 1156   6                              RemFlag[0] = 1;
 1157   6                              StartRem[0]++;
 1158   6                              EnterPage(PAGE_REM);
 1159   6                             
 1160   6                          }
 1161   5                      }
 1162   4                      else
 1163   4                      {
 1164   5                          if(StartRem[0] != 0)
 1165   5                          {
 1166   6                              RemFlag[0]  = 0; 
 1167   6                              SendParam();
 1168   6                              ModeHint(); 
 1169   6                              EnterPage(PAGE_START);
 1170   6                              StartRem[0] = 0;
 1171   6                          }
 1172   5                      }
 1173   4                      break;
 1174   4                  }
 1175   3              }
 1176   2              
 1177   2              case 1:
 1178   2              {
 1179   3                  if(SysParam.RemCtlFlag)
 1180   3                  {
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 19  

 1181   4                       if(!RemFlag[1])
 1182   4                      {
 1183   5                          RemFlag[1] = 1;
 1184   5                          StartRem[1]++;
 1185   5                          EnterPage(PAGE_REM);
 1186   5                          
 1187   5                       }
 1188   4                  }
 1189   3                  else
 1190   3                  {
 1191   4                       if(StartRem[1] != 0)
 1192   4                      {
 1193   5                          
 1194   5                          RemFlag[1] = 0;
 1195   5                          if(RunStatus.Running)
 1196   5                          {
 1197   6                              SendParam();
 1198   6                              ModeHint(); 
 1199   6                              CheckAlarm();
 1200   6                              EnterPage(PAGE_MAIN);
 1201   6                          }
 1202   5                          else
 1203   5                          {
 1204   6                              SendParam();
 1205   6                              ModeHint(); 
 1206   6                              UpdataUI();
 1207   6                              EnterPage(PAGE_MAIN);
 1208   6                          }
 1209   5                          StartRem[1] = 0;
 1210   5                       }
 1211   4                  }
 1212   3                  break;
 1213   3              }
 1214   2              
 1215   2               case 2:
 1216   2              {
 1217   3                  if(SysParam.RemCtlFlag)
 1218   3                  {
 1219   4                       if(!RemFlag[2])
 1220   4                      {
 1221   5                          RemFlag[2] = 1;
 1222   5                          StartRem[2]++;
 1223   5                          EnterPage(PAGE_REM);
 1224   5                         
 1225   5                       }
 1226   4                  }
 1227   3                  else
 1228   3                  {
 1229   4                       if(StartRem[2] != 0)
 1230   4                      {
 1231   5                          RemFlag[2] = 0;
 1232   5                          SendParam();
 1233   5                          ModeHint(); 
 1234   5                          EnterPage(PAGE_SET);
 1235   5                          StartRem[2] = 0;
 1236   5                       }
 1237   4                  }
 1238   3                  break;
 1239   3              }
 1240   2               
 1241   2               case 3:
 1242   2              {
 1243   3                  if(SysParam.RemCtlFlag)
 1244   3                  {
 1245   4                       if(!RemFlag[3])
 1246   4                      {
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 20  

 1247   5                          RemFlag[3] = 1;
 1248   5                          StartRem[3]++;
 1249   5                          EnterPage(PAGE_REM);
 1250   5                          
 1251   5                       }
 1252   4                  }
 1253   3                  else
 1254   3                  {
 1255   4                       if(StartRem[3] != 0)
 1256   4                      {
 1257   5                          RemFlag[3] = 0;
 1258   5                          SendParam();
 1259   5                          ModeHint(); 
 1260   5                          EnterPage(PAGE_TIME);
 1261   5                          StartRem[3] = 0;
 1262   5                       }
 1263   4                  }
 1264   3                 break; 
 1265   3              }  
 1266   2          }
 1267   1      }
 1268          
 1269          //远程控制向从机写
 1270          void RemCtlWrite()
 1271          {
 1272   1          SendRemCtlCmd(1, CMD_WRITE_REG, MODBUS_PARAM_ADD, 2, (BYTE *)&ModBusParam);
 1273   1          Delay(50);
 1274   1          SendRemCtlCmd(1, CMD_WRITE_REG, MODBUS_STATUS_ADD, 1, (BYTE *)&ModBusStatus);
 1275   1          Delay(50);
 1276   1          SendRemCtlCmd(1, CMD_WRITE_REG, MODBUS_INFO_ADD, 1, (BYTE *)&ModBusInfo);
 1277   1      }
 1278          
 1279          
 1280          //远程控制读从机
 1281          void RemCtlTask()
 1282          {   
 1283   1              WORD RegCnt = 3;
 1284   1              
 1285   1      //    if (RunStatus.Running)
 1286   1      //    {
 1287   1               if(RemReadflag == 1)
 1288   1              {
 1289   2                  RemReadflag = 0;
 1290   2      
 1291   2                  SendRemCtlCmd(1, CMD_READ_REG, MODBUS_PARAM_ADD, RegCnt, NULL);
 1292   2                  Delay(50);
 1293   2                  SendRemCtlCmd(1, CMD_READ_REG, MODBUS_STATUS_ADD, 11, NULL);
 1294   2                  Delay(50);
 1295   2      //            SendRemCtlCmd(1, CMD_READ_REG, MODBUS_INFO_ADD, 3, NULL);
 1296   2      //            Delay(50);
 1297   2      
 1298   2              }
 1299   1          //}
 1300   1      }
 1301          
 1302          void main(void)
 1303          {
 1304   1          BYTE i = 0;
 1305   1          SysInit();
 1306   1          IoInit();
 1307   1          PW_MAIN(0);  // 主电源
 1308   1          LedInit();
 1309   1          
 1310   1          RUN_LED(1);
 1311   1         
 1312   1          Delay(200);
C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 21  

 1313   1          
 1314   1          Timer0Init();
 1315   1          Delay(200);
 1316   1          Adc_Init();
 1317   1          Delay(200);
 1318   1          
 1319   1          UART1_config();
 1320   1          UART2_config();
 1321   1          UART3_config();
 1322   1          UART4_config();
 1323   1          ClearUart1Buf();
 1324   1          ClearUart2Buf();
 1325   1          ClearUart3Buf();
 1326   1          ClearUart4Buf();
 1327   1          
 1328   1          // 待CPU稳定了再读参数
 1329   1          Delay(500);
 1330   1          ReadParam();
 1331   1          Delay(200);
 1332   1      
 1333   1          SyncModBusDev();
 1334   1          //RemCtlWrite();
 1335   1          
 1336   1          
 1337   1          RUN_LED(0);
 1338   1      
 1339   1          #if 0
                   while(1)
                   {
                       RUN_LED(0);
                       Delay(800);
                       RUN_LED(1);
                       Delay(200);
                   }
                   #endif
 1348   1          
 1349   1          
 1350   1          EA = 1;     //打开总中断
 1351   1      
 1352   1          WDT_CONTR |= (1<<5) |  7;  // 启动开门狗，约8秒
 1353   1      
 1354   1          Delay(200);
 1355   1          InitLcd();
 1356   1          SysParam.RemCtlFlag = 0;
 1357   1          PageSwitch = 0;
 1358   1          while(1)
 1359   1          {
 1360   2              TimerTask();
 1361   2              HndInput();
 1362   2               
 1363   2              //RemCtlWrite();
 1364   2               
 1365   2              Uart1Hnd();
 1366   2              Uart2Hnd();
 1367   2              Uart3Hnd();
 1368   2              RemPageCtl();
 1369   2              
 1370   2              FlowTask();
 1371   2              
 1372   2              Uart4Hnd();
 1373   2              RemCtlTask();
 1374   2          }
 1375   1      }
 1376          
 1377          

C251 COMPILER V5.60.0,  main                                                               08/10/23  18:34:43  PAGE 22  


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      5271     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       214     ------
  xdata-const size     =    ------     ------
  edata size           =       148     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       256     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
