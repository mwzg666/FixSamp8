C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\obj\main.obj
COMPILER INVOKED BY: D:\KeilMDK\C251\BIN\C251.EXE main.c XSMALL OPTIMIZE(0,SPEED) BROWSE INCDIR(.\Ads1110;.\Flash;.\mcp4
                    -725;.\IIC;.\MwPro;.\Uart;.\Lcd;.\ModBus;.\Temperaturn) PRINT(.\obj\main.lst) OBJECT(.\obj\main.obj) 

stmt  level    source

    1          #include "main.h"
    2          #include "mcp4725.h"
    3          #include "Lcd.h"
    4          #include "LcdApp.h"
    5          #include "ModBus.h"
    6          #include "Temper.h"
    7          #include "FlowMeter.h"
    8          #include "ModBusDev.h"
    9          #include "ModBusHost.h"
   10          
   11          
   12          BYTE code VERSION = 100;  // V1.0.0
   13          
   14          BYTE xdata StrTmp[64] = {0};
   15          //BYTE xdata Valve[8] = {0};
   16          
   17          BYTE ChannelError[FLOW_METER_CNT] ={0};
   18          
   19          #define Log //((CSampDemoDlg *)theApp.m_pMainWnd)->AddLog
   20          
   21          #define PARAM_SIGN  0x3132
   22          SYS_PARAM xdata SysParam;
   23          RUN_STATUS xdata RunStatus;
   24          REM_REGADDR xdata RemRegAddr;
   25          
   26          float SimFlow = 35.0;
   27          
   28          u16 SendFlowTim = 0;
   29          BYTE SendFlowFlag = 0;
   30          
   31          u16 RemReadTim = 0;     //远程控制读从机开始时间
   32          BYTE RemReadflag = 0;   //远程控制读从机开始标志
   33          BYTE Remflag_RW = 0;
   34          
   35          u16 LcdBusyTim = 0;
   36          BYTE LcdBusyFlag = 0;
   37          BYTE ChNum = 1;
   38          
   39          BYTE g_Output[OUT_IO_COUNT]      = {0,0,0,0,0};   // 上电蓝灯亮 // 
   40          BYTE g_OutStatus[OUT_IO_COUNT]   = {0,0,0,0,0};
   41          
   42          BYTE PageSwitch = 0;                                //远程控制界面选择
   43          BYTE StartRem[5] = {0,0,0,0,0};
   44          BYTE RemFlag[5] = {0,0,0,0,0};
   45          
   46          
   47          u16  Timer0Cnt = 0;
   48          
   49          BYTE g_Key_Confrom  = 0; 
   50          BYTE g_Key_Power  = 0; 
   51          BYTE g_Key_Input  = 0; 
   52          BYTE Input_Status = 0;
   53          
   54          WORD gRunTime = 0;
   55          
   56          void DebugMsg(char *msg)
   57          {
   58   1          BYTE len = (BYTE)strlen(msg);
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 2   

   59   1          //Uart1Send((BYTE *)msg,len);
   60   1      }
   61          
   62          void DebugInt(int msg)
   63          {
   64   1          memset(StrTmp,0,64);
   65   1          sprintf(StrTmp,"%x\r\n",msg);
   66   1          DebugMsg(StrTmp);
   67   1      }
   68          
   69          void DumpCmd(BYTE *dat, BYTE len)
   70          {
   71   1          BYTE i;
   72   1          memset(StrTmp,0,64);
   73   1          for (i=0;i<len;i++)
   74   1          {
   75   2              if (strlen(StrTmp) >= 60)
   76   2              {
   77   3                  break;
   78   3              }
   79   2              sprintf(&StrTmp[i*3], "%02X ", dat[i]);
   80   2          }
   81   1          sprintf(&StrTmp[i*3], "\r\n");
   82   1          DebugMsg(StrTmp);
   83   1      }
   84          
   85          
   86          void Error()
   87          {
   88   1          while(1)
   89   1          {
   90   2              RUN_LED(1);
   91   2              Delay(50);
   92   2              RUN_LED(0);
   93   2              Delay(50);
   94   2          }
   95   1          
   96   1      }
   97          
   98          
   99          void SysInit()
  100          {
  101   1          HIRCCR = 0x80;           // 启动内部高速IRC
  102   1          while(!(HIRCCR & 1));
  103   1          CLKSEL = 0;              
  104   1      }
  105          
  106          void IoInit()
  107          {
  108   1          EAXFR = 1;
  109   1          WTST = 0;   //设置程序指令延时参数，赋值为0可将CPU执行指令的速度设置为最快
  110   1      
  111   1          P0M1 = 0x00;   P0M0 |= (1<<4) ;                     // P0.0 P0.1 P0.4 推挽输出
  112   1          P1M1 = (1<<4)|(1<<3);   P1M0 = 0x00;                       //设置为准双向口
  113   1          P2M1 = 0x00;   P2M0 |= 0x00;                      // P2.2 推挽输出
  114   1          P3M1 = 0x00;   P3M0 |= (1<<2)|(1<<3)|(1<<4);        //设置为准双向口
  115   1          P4M1 = 0x00;   P4M0 = 0x00;                       //设置为准双向口
  116   1          P5M1 = 0x00;   P5M0 |= (1<<0) | (1<<2);             //设置为准双向口
  117   1          P6M1 = 0x00;   P6M0 |= (1<<7);     //设置为准双向口
  118   1          P7M1 = 0x00;   P7M0 = 0x00;                         //设置为准双向口
  119   1      }
  120          
  121          
  122          void SensorInit()
  123          {
  124   1          // P1.0 -- 下降缘中断
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 3   

  125   1          P1IM0 = 0;
  126   1          P1IM1 = 0;
  127   1      
  128   1          // 优先级2
  129   1          //PIN_IP  |= (1<<1);
  130   1          PINIPH |= (1<<1);
  131   1          //P1_IP  = 1; // |= (1<<1);
  132   1          //P1_IPH = 1; //|= (1<<1);
  133   1      
  134   1          // 允许中断
  135   1          P1INTE |= (1<<0) | (1<<1) | (1<<4) | (1<<5);
  136   1      }
  137          
  138          
  139          
  140          void Timer0Init()
  141          {
  142   1          AUXR = 0x00;    //Timer0 set as 12T, 16 bits timer auto-reload, 
  143   1          TH0 = (u8)(Timer0_Reload / 256);
  144   1          TL0 = (u8)(Timer0_Reload % 256);
  145   1          ET0 = 1;    //Timer0 interrupt enable
  146   1          TR0 = 1;    //Tiner0 run
  147   1          
  148   1          // 中断优先级3
  149   1          PT0  = 0;
  150   1          PT0H = 0;
  151   1      }
  152          
  153          // 10ms 中断一下
  154          void Timer0Int (void) interrupt 1
  155          {
  156   1          Timer0Cnt ++;
  157   1      }
  158          
  159          #if 0
               // 公用中断服务程序
               void CommInt (void) interrupt 13
               {
                   u8 intf =  P1INTF;
                   
                   if (intf)
                   {
                       P1INTF = 0;
               
                       if (intf & (1<<0))  // P1.0 中断
                       {
                           Counter[0] ++;
                       }
               
                       if (intf & (1<<1))  // P1.1 中断
                       {
                           Counter[1] ++;
                       }
               
                       if (intf & (1<<4))  // P1.4 中断
                       {
                           Counter[2] ++;
                       }
               
                       if (intf & (1<<5))  // P1.5 中断
                       {
                           Counter[3] ++;
                       }
                   }
                   
               }
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 4   

               #endif
  192          
  193          
  194          void OutCtl(alt_u8 id, alt_u8 st)
  195          {
  196   1          if (g_OutStatus[id] == st)
  197   1          {
  198   2              return;
  199   2          }
  200   1      
  201   1          g_OutStatus[id] = st;
  202   1          
  203   1          switch(id)
  204   1          {   
  205   2              case LIGHT_BLUE: 
  206   2              {
  207   3                  (st)? BLU_LIGHT(1) : BLU_LIGHT(0); 
  208   3                  break;
  209   3              }
  210   2          
  211   2              case LIGHT_YELLOW: 
  212   2              {
  213   3                  (st)? YEL_LIGHT(1):YEL_LIGHT(0);
  214   3                  break;
  215   3              }
  216   2      
  217   2              case GAS_BUMP:      //泵
  218   2              {
  219   3                  (st)? BUMP_M(1) : BUMP_M(0);
  220   3                  break;
  221   3              }
  222   2      
  223   2              case EX_FAN:        //风扇
  224   2              {
  225   3                  (st)? FANS_M(1) : FANS_M(0);
  226   3                  break;
  227   3              }
  228   2      
  229   2              case ALARM_SOUND:   //报警
  230   2              {
  231   3                  (st)? ALARM(1) : ALARM(0);       
  232   3                  break;
  233   3              }
  234   2          }
  235   1      
  236   1          
  237   1      }
  238          
  239          void OutFlash(alt_u8 id)
  240          {
  241   1          static alt_u16 OutTimer[OUT_IO_COUNT] = {0,0,0,0,0};
  242   1          if (OutTimer[id] ++ > LED_FLASH_TIME/10)
  243   1          {
  244   2              OutTimer[id] = 0;
  245   2              if (g_OutStatus[id] == 1)
  246   2              {
  247   3                  OutCtl(id, 0);
  248   3              }
  249   2              else
  250   2              {
  251   3                  OutCtl(id, 1);
  252   3              }
  253   2          }
  254   1      }
  255          
  256          void IoCtlTask()
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 5   

  257          {
  258   1          alt_u8 i;
  259   1          for (i=0;i<OUT_IO_COUNT;i++)
  260   1          {
  261   2              if (g_Output[i] == 2)
  262   2              {
  263   3                  OutFlash(i);
  264   3              }
  265   2              else
  266   2              {
  267   3                  OutCtl(i, g_Output[i]);
  268   3              }
  269   2          }
  270   1      }
  271          
  272          // 板载指示灯
  273          void RunLed(u16 dt)
  274          {   
  275   1          static u16 tm = 0;
  276   1          u16 to = 3000;
  277   1          tm += dt;
  278   1      
  279   1          if (tm > to)
  280   1          {
  281   2              tm = 0;
  282   2              RUN_LED(0);
  283   2          }
  284   1          else if (tm > (to-100))
  285   1          {
  286   2              RUN_LED(1);
  287   2          }
  288   1      }
  289          
  290          
  291          
  292          void Task1s()
  293          {
  294   1          static BYTE tm = 0;
  295   1      
  296   1          CLR_WDT = 1;  // 喂狗
  297   1          tm++;
  298   1          if(tm == 10)
  299   1          {
  300   2              ADC_Temp();
  301   2              SyncModBusDev();
  302   2              tm = 0;
  303   2          } 
  304   1          
  305   1          if((tm == 6)||(tm == 3))
  306   1          {
  307   2              GetRetCode();
  308   2          }
  309   1          
  310   1          if(tm == 9)
  311   1          {
  312   2              if (RunStatus.Running)
  313   2              {  
  314   3                  DevRun();
  315   3              }
  316   2          }
  317   1          //RemCtlWrite();
  318   1      }
  319          
  320          
  321          void TimerTask()
  322          {
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 6   

  323   1          u16 delta = 0;
  324   1          static u16 Time1s = 0;
  325   1          
  326   1          if (Timer0Cnt)
  327   1          {
  328   2              delta = Timer0Cnt * 10;
  329   2              Timer0Cnt = 0;
  330   2      
  331   2              if (RX2_Cnt > 0)
  332   2              {
  333   3                  Rx2_Timer += delta;
  334   3              }
  335   2      
  336   2              if(RX3_Cnt > 0)
  337   2              {
  338   3                  Rx3_Timer += delta;
  339   3              }
  340   2              
  341   2              if(RX4_Cnt > 0)
  342   2              {
  343   3                  Rx4_Timer += delta;
  344   3              }
  345   2              
  346   2              SendFlowTim += delta;
  347   2              if(SendFlowTim > 220)
  348   2              {
  349   3                  SendFlowTim = 0;
  350   3                  SendFlowFlag = 1;
  351   3              }
  352   2      
  353   2              RemReadTim += delta;
  354   2              if(RemReadTim > 250)
  355   2              {
  356   3                  RemReadTim = 0;
  357   3                  RemReadflag = 1;
  358   3              }
  359   2      
  360   2              if (gRunTime < 5000)
  361   2              {
  362   3                  gRunTime += delta;
  363   3              }
  364   2      
  365   2              //if (g_CommIdleTime < 300)
  366   2              //{
  367   2                  //g_CommIdleTime += delta;
  368   2              //}
  369   2      
  370   2              #ifdef IRDA_FUN
                       if (IrDAStart == 1)
                       {
                           IrDATimer += delta;
                       }
                       #endif
  376   2      
  377   2              Time1s += delta;
  378   2              if (Time1s >= 100)
  379   2              {
  380   3                  Time1s = 0;
  381   3                  Task1s();
  382   3              }
  383   2              RunLed(delta);
  384   2              IoCtlTask();
  385   2              GetValve();
  386   2              ShowRemCh();
  387   2          }
  388   1      }
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 7   

  389          
  390          
  391          
  392          void Delay(WORD ms)
  393          {
  394   1          WORD t = 1000;
  395   1          while(ms--)
  396   1          {
  397   2              for (t=0;t<1000;t++) ;
  398   2          }
  399   1      }
  400          
  401          
  402          WORD ParamCheck(BYTE *buf, WORD len)
  403          {
  404   1          WORD dwSum = 0;
  405   1          WORD i;
  406   1      
  407   1          for (i = 0; i < len; i++)
  408   1          {
  409   2              dwSum += buf[i];
  410   2          }
  411   1      
  412   1          return dwSum;
  413   1      }
  414          
  415          /*
  416          void DefSenParam()
  417          {
  418              BYTE i;
  419              for (i=0; i<SENSOR_COUNT; i++)
  420              {
  421                  SysParam.SenParam[i].LOW_REVISE_COE_A = 1;
  422                  SysParam.SenParam[i].LOW_REVISE_COE_B = 1;
  423                  SysParam.SenParam[i].LOW_REVISE_COE_C = 1;
  424          
  425                  SysParam.SenParam[i].HIG_REVISE_COE_A = 1;
  426                  SysParam.SenParam[i].HIG_REVISE_COE_B = 1;
  427                  SysParam.SenParam[i].HIG_REVISE_COE_C = 1;
  428          
  429                  SysParam.SenParam[i].SUPER_REVISE_COE_A = 1;
  430                  SysParam.SenParam[i].SUPER_REVISE_COE_B = 1;
  431                  SysParam.SenParam[i].SUPER_REVISE_COE_C = 1;
  432          
  433                  SysParam.SenParam[i].DET_THR_1 = 500;
  434                  SysParam.SenParam[i].DET_THR_2 = 150;
  435                  SysParam.SenParam[i].DET_THR_3 = 150;
  436          
  437                  SysParam.SenParam[i].DET_TIME = 1000;
  438                  SysParam.SenParam[i].HV_THR = 1000;
  439              }
  440          }
  441          */
  442          
  443          /*
  444          void DefSenAlarm()
  445          {
  446              BYTE i;
  447              for (i=0; i<SENSOR_COUNT; i++)
  448              {
  449                  SysParam.AlmParam[i].DOSE_RATE_ALARM_1 = 300;
  450                  SysParam.AlmParam[i].DOSE_RATE_ALARM_2 = 400;
  451                  SysParam.AlmParam[i].CUM_DOSE_RATE_ALARM_1 = 300;
  452                  SysParam.AlmParam[i].CUM_DOSE_RATE_ALARM_2 = 400;
  453                  SysParam.AlmParam[i].INVALID_ALRAM_1 = 8000;
  454                  SysParam.AlmParam[i].INVALID_ALRAM_2 = 10000;
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 8   

  455              }
  456          }
  457          */
  458          
  459          void ReadParam()
  460          {
  461   1          EEPROM_read(0, (BYTE *)&SysParam, sizeof(SYS_PARAM));
  462   1      
  463   1          #if 0
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(SYS_PARAM));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(HOST_SENSOR_PARAM));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(HOST_ALRAM_PARA));
                   DebugMsg((char *)StrTmp);
               
                   memset(StrTmp,0,32);
                   sprintf((char *)StrTmp,"%d \r\n",sizeof(float));
                   DebugMsg((char *)StrTmp);
                   
                   //Rs485Send((BYTE *)&SysParam, sizeof(SYS_PARAM));
                   
                   
                   if (SysParam.Sign != PARAM_SIGN)
                   {
                       DebugMsg("Sign error. \r\n");
                   }
               
                   if (SysParam.Sum != ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2))
                   {
                       DebugMsg("Param Check error. \r\n");
                   }
                   #endif
  493   1      
  494   1         
  495   1          if ( (SysParam.Sign != PARAM_SIGN) ||
  496   1               (SysParam.Sum != ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2)) )
  497   1          {
  498   2              //SysParam.Sign = PARAM_SIGN;
  499   2              //SysParam.Address = 1;
  500   2              ParamDef();
  501   2              //DefSenParam();
  502   2              //DefSenAlarm();
  503   2              WriteParam();
  504   2      
  505   2              //DebugMsg("Def Param. \r\n");
  506   2          }
  507   1      }
  508          
  509          
  510          void WriteParam()
  511          {
  512   1          EA = 0;    
  513   1          
  514   1          EEPROM_SectorErase(0);
  515   1          EEPROM_SectorErase(512);
  516   1          SysParam.Sum = ParamCheck((BYTE *)&SysParam, sizeof(SYS_PARAM)-2);
  517   1          if (!EEPROM_write(0, (BYTE *)&SysParam, sizeof(SYS_PARAM)))
  518   1          {
  519   2              Error();
  520   2          }
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 9   

  521   1          //printf("Write34= OK\r\n");
  522   1          EA = 1;     //打开总中断
  523   1      }
  524          
  525          BYTE GetInput()
  526          {
  527   1          // 当前只有一个开关机状态 P2.1
  528   1          static BYTE his = LOCK_BIT();
  529   1          BYTE st = POWER_LOCK();
  530   1      
  531   1          if (st != his)
  532   1          {
  533   2              Delay(50);
  534   2              if ( st == POWER_LOCK() )
  535   2              {
  536   3                  his = st;
  537   3                  return st;
  538   3              }
  539   2          }
  540   1      
  541   1          return 0xFF;
  542   1      }
  543          
  544          
  545          void PowerOff()
  546          {
  547   1          PW_MAIN(0);
  548   1      
  549   1          while(1)
  550   1          {
  551   2              ;
  552   2          }
  553   1      }
  554          
  555          void HndInput()
  556          {
  557   1          static bool em = false;
  558   1          if(STOP_M() == 0)
  559   1          {
  560   2              Delay(10);
  561   2              if (STOP_M() == 0)
  562   2              {
  563   3                  if (RunStatus.Running)
  564   3                  {
  565   4                      StopSamp(false);
  566   4                  }
  567   3              }
  568   2      
  569   2              if (em == false)
  570   2              {
  571   3                  em = true;
  572   3                  ShowEmStop(em);
  573   3              }
  574   2          }
  575   1          else
  576   1          {
  577   2              if (em)
  578   2              {
  579   3                  em = false;
  580   3                  ShowEmStop(em);
  581   3              }
  582   2          }
  583   1      }
  584          
  585          /*
  586          void ReportInput()
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 10  

  587          {
  588              BYTE PwOff = POWER_OFF;
  589              
  590              if (g_CommIdleTime > 200)
  591              {
  592                  if (g_Key_Confrom)
  593                  {
  594                      g_Key_Confrom = 0;
  595                      SendPcCmd(0, CMD_CERTAINKEY, NULL, 0);
  596                      return;
  597                  }
  598          
  599                  if (g_Key_Power)
  600                  {
  601                      g_Key_Power = 0;
  602                      SendPcCmd(0, CMD_POWER, &PwOff, 1);
  603                      return;
  604                  }
  605          
  606                  #if 0
  607                  if (g_Key_Input)
  608                  {
  609                      g_Key_Input = 0;
  610                      SendPcCmd(0, CMD_INPUT, &Input_Status, 1);
  611                  }
  612                  #endif
  613              }
  614          }
  615          */
  616          
  617          void LedInit()
  618          {
  619   1          // 初始状态都为0
  620   1      
  621   1          // 指示灯
  622   1          YEL_LIGHT(0);   // 黄灯
  623   1          BLU_LIGHT(0);   // 蓝灯
  624   1          
  625   1          CloseValve();   // 电磁阀
  626   1          BUMP_M(0);      // 泵
  627   1          FANS_M(0);      // 风扇
  628   1          ALARM(0);       // 报警音
  629   1      }
  630          
  631          
  632          void ParamDef()
  633          {
  634   1          BYTE i;
  635   1          
  636   1          SysParam.Sign     = PARAM_SIGN;
  637   1          SysParam.Address = 1;
  638   1          SysParam.BkLight = 50;
  639   1      
  640   1          SysParam.SampMode = MODE_TIME;
  641   1          SysParam.SampTime = 5;  
  642   1          SysParam.SampVol   = 2;
  643   1          SysParam.AlarmThres   = 10;
  644   1          for (i=0;i<CHANNLE_NUM;i++)
  645   1          {
  646   2              SysParam.SampFlow[i] = 35;
  647   2              //SysParam.Valve[i] = 0;
  648   2          }
  649   1      
  650   1          SysParam.Enable = 0x1F;
  651   1          SysParam.RemCtlFlag = false;
  652   1      
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 11  

  653   1          RemRegAddr.SypAddr = MODBUS_PARAM_ADD;
  654   1          RemRegAddr.StuAddr = MODBUS_STATUS_ADD;
  655   1          RemRegAddr.InfoAddr = MODBUS_INFO_ADD;
  656   1      }
  657          
  658          void SaveParam()
  659          {
  660   1          //CString t;
  661   1          //t.Format(_T("SaveParam: %02X\r\n"), SysParam.Enable);
  662   1          //Log(t);
  663   1          //DebugMsg("123");
  664   1          WriteParam();
  665   1      }
  666          
  667          
  668          void UpdataUI()
  669          {
  670   1          BYTE i;
  671   1          for (i=0;i<CHANNLE_NUM;i++)
  672   1          {
  673   2              //printf("UpData= OK\r\n");
  674   2              ChannelAlarm[i] = ((SysParam.Enable & (1<<i)) == 0)?0:1;
  675   2          }
  676   1          ShowStatus();
  677   1          Delay(200);
  678   1          StatusColor(true);
  679   1      }
  680          
  681          void InitLcd()
  682          {   
  683   1          memset(&RunStatus, 0, sizeof(RUN_STATUS));
  684   1          memset(&RunInfo, 0, sizeof(RUN_INFO));
  685   1          memset(&RealFlow, 0, sizeof(RealFlow));
  686   1          
  687   1          //ParamDef();
  688   1          ModeHint();
  689   1          Delay(200);
  690   1          HideModule(MP_HINT_END);
  691   1          Delay(200);
  692   1          UpdataUI();    
  693   1          Delay(200);
  694   1          SendParam();
  695   1          Delay(200);
  696   1          SetBkLight(false);
  697   1          Delay(200);
  698   1          ShowDevInfo();
  699   1          Delay(200);
  700   1      }
  701          
  702          
  703          void GetFlow()
  704          {
  705   1          BYTE i;
  706   1          WORD  w;
  707   1          DWORD d;
  708   1      
  709   1          
  710   1          for (i=0;i<CHANNLE_NUM;i++)
  711   1          {
  712   2              if (SysParam.Enable & (1<<i))
  713   2              {
  714   3                  RunStatus.Flow[i] = RealFlow[i].val;  // 模拟 -- 实际要从流量计中读取
  715   3                  w = (WORD)(RunStatus.Flow[i]*10);
  716   3                  RunInfo.ChFlow[i].Flow = SwWord(w);
  717   3                  
  718   3                  RunStatus.Volume[i] =  RealFlow[i].Totol; 
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 12  

  719   3                  w = (WORD)(RunStatus.Volume[i]*10);
  720   3                  RunInfo.ChFlow[i].Vol = SwWord(w);
  721   3              }
  722   2          }
  723   1      
  724   1          // 总流量
  725   1          RunStatus.TotleFlow = RealFlow[8].val;
  726   1          d = (DWORD)(RealFlow[8].val*10);
  727   1          RunInfo.TotFlow.Flow = SwDWord(d);
  728   1      
  729   1          // 总体积
  730   1          RunStatus.TotleVol = RealFlow[8].Totol;
  731   1          d = (DWORD)(RealFlow[8].Totol*10);
  732   1          RunInfo.TotFlow.Vol   = SwDWord(d);
  733   1      }
  734          
  735          void StartSamp()
  736          {
  737   1          memset(&RunStatus, 0, sizeof(RUN_STATUS));
  738   1          memset(&RunInfo, 0, sizeof(RUN_INFO));
  739   1          memset(&RealFlow, 0, sizeof(RealFlow));
  740   1          
  741   1          RunStatus.Running = true;
  742   1          g_Output[LIGHT_BLUE] = 1;
  743   1          CheckValve();
  744   1          OpenPump();
  745   1          SetStartBtn(0);
  746   1      
  747   1      }
  748          
  749          void StopSamp(bool Auto)
  750          {
  751   1          ClosePump();
  752   1          memset(RealFlow,0, sizeof(RealFlow));
  753   1      
  754   1          RunStatus.Running = false;
  755   1          g_Output[LIGHT_BLUE] = 0;
  756   1          
  757   1          SetStartBtn(1);  // 按钮自动变为“开始”
  758   1          
  759   1          if (Auto)  // 自动结束
  760   1          {
  761   2              // 显示取样结束提示框
  762   2              ShowModule(MP_HINT_END, REG_HINT_END);
  763   2          }
  764   1      }
  765          
  766          // 定时模式
  767          void TimingMode()
  768          {
  769   1          if (RunStatus.RunTime >= ((DWORD)SysParam.SampTime) * 60)
  770   1          {
  771   2              StopSamp(true);
  772   2          }
  773   1      }
  774          
  775          
  776          // 定量模式
  777          void VolumeMode()
  778          {
  779   1          if (RunStatus.TotleVol >= SysParam.SampVol)
  780   1          {
  781   2              StopSamp(true);
  782   2          }
  783   1      }
  784          
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 13  

  785          
  786          void RunCheck()
  787          {
  788   1          switch (SysParam.SampMode)
  789   1          {
  790   2              case MODE_TIME:  TimingMode();  break;
  791   2              case MODE_VOL:   VolumeMode();  break;
  792   2          }
  793   1      }
  794          
  795          void AbnorAlaerm()
  796          {   
  797   1          BYTE i;
  798   1          bool HaveAlarm = false;
  799   1      
  800   1          
  801   1          
  802   1          for(i = 0;i < CHANNLE_NUM;i++)
  803   1          {
  804   2              if( (ChannelAlarm[i] == ALM_FLOW_ABNOR) ||
  805   2                  (ChannelAlarm[i] ==  ALM_FLOW_LOW) || 
  806   2                  (ChannelAlarm[i] == ALM_FLOW_HIGH)  )
  807   2              {
  808   3                  HaveAlarm = true;
  809   3                  break;
  810   3              }
  811   2          }
  812   1      
  813   1          if (HaveAlarm)
  814   1          {
  815   2              g_Output[LIGHT_YELLOW] = 1;
  816   2              g_Output[ALARM_SOUND] = 2;
  817   2          }
  818   1          else
  819   1          {
  820   2              g_Output[LIGHT_YELLOW] = 0;
  821   2              g_Output[ALARM_SOUND] = 0;
  822   2          }
  823   1      }
  824          void CheckAlarm()
  825          {
  826   1          BYTE i;
  827   1          float flow;
  828   1          
  829   1          for (i=0;i<CHANNLE_NUM;i++)
  830   1          {
  831   2              if (SysParam.Enable & (1<<i))
  832   2              {
  833   3                  flow = RunStatus.Flow[i];
  834   3                  if (flow > SysParam.SampFlow[i]*(100+SysParam.AlarmThres)/100)
  835   3                  {
  836   4                      ChannelAlarm[i] = ALM_FLOW_HIGH;
  837   4                  }
  838   3                  else if (flow < SysParam.SampFlow[i]*(100-SysParam.AlarmThres)/100)
  839   3                  {
  840   4                      ChannelAlarm[i] = ALM_FLOW_LOW;
  841   4                  }
  842   3                  else
  843   3                  {
  844   4                      ChannelAlarm[i] = ALM_FLOW_NOR;
  845   4                  }
  846   3              }
  847   2              else
  848   2              {
  849   3                  ChannelAlarm[i] = ALM_CH_DISABLE;
  850   3              }
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 14  

  851   2              
  852   2              if( (ChannelError[i] > 3) && (ChannelAlarm[i] != ALM_CH_DISABLE) )
  853   2              {
  854   3                  ChannelAlarm[i] = ALM_FLOW_ABNOR;
  855   3              }
  856   2          }
  857   1      
  858   1          if (memcmp(HisAlarm,ChannelAlarm,CHANNLE_NUM) != 0)
  859   1          {
  860   2              // 报警有变化才更新界面
  861   2              Delay(200);
  862   2              ShowStatus();
  863   2              Delay(200);
  864   2              AbnorAlaerm();
  865   2              StatusColor(false);
  866   2      
  867   2              memcpy(HisAlarm,ChannelAlarm,8);
  868   2          }
  869   1      }
  870          
  871          // 1秒运行一次
  872          void DevRun()
  873          {
  874   1          RunStatus.RunTime ++;
  875   1          
  876   1          // 1. 获取流量
  877   1          GetFlow();
  878   1      
  879   1          // 2. 显示流量和状态
  880   1          ShowFlow();
  881   1          //Delay(200);
  882   1          
  883   1          // 3. 检查报警状态  
  884   1          if (RunStatus.RunTime > 10)
  885   1          {
  886   2              // 运行时间大于10秒才检测
  887   2              CheckAlarm();
  888   2          }
  889   1          
  890   1          // 4. 根据模式判断是否结束取样
  891   1          RunCheck();
  892   1      }
  893          
  894          
  895          //获取电磁阀状态
  896          void GetValve()
  897          {
  898   1          BYTE i;
  899   1          for(i = 0;i<CHANNLE_NUM;i++)
  900   1          {
  901   2              if(SysParam.Enable & (1<<i))
  902   2              {
  903   3                  RemChStatus[i] = 1;
  904   3                 //SysParam.Valve[i] = 1;
  905   3              }
  906   2              else
  907   2              {
  908   3                  RemChStatus[i] = 0;
  909   3      //           SysParam.Valve[i] = 0;
  910   3              }
  911   2          }
  912   1      
  913   1      }
  914          
  915          //查询电磁阀状态
  916          void CheckValve()
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 15  

  917          {
  918   1          BYTE i;
  919   1          for(i = 0;i<CHANNLE_NUM;i++)
  920   1          {
  921   2              if(RemChStatus[i])//(SysParam.Valve[i])
  922   2              {
  923   3                  switch(i)
  924   3                  {
  925   4                      case 0 : VALVE0(1); break;
  926   4                      case 1 : VALVE1(1); break;
  927   4                      case 2 : VALVE2(1); break;
  928   4                      case 3 : VALVE3(1); break;
  929   4                      case 4 : VALVE4(1); break;
  930   4                      case 5 : VALVE5(1); break;
  931   4                      case 6 : VALVE6(1); break;
  932   4                      case 7 : VALVE7(1); break;  
  933   4                  }
  934   3              }
  935   2              else
  936   2              {
  937   3                  switch(i)
  938   3                  {
  939   4                      case 0 : VALVE0(0); break;
  940   4                      case 1 : VALVE1(0); break;
  941   4                      case 2 : VALVE2(0); break;
  942   4                      case 3 : VALVE3(0); break;
  943   4                      case 4 : VALVE4(0); break;
  944   4                      case 5 : VALVE5(0); break;
  945   4                      case 6 : VALVE6(0); break;
  946   4                      case 7 : VALVE7(0); break;  
  947   4                  }
  948   3              }
  949   2          }
  950   1          Delay(20);
  951   1      }
  952          
  953          //关闭电磁阀
  954          void CloseValve()
  955          {
  956   1          VALVE0(0);
  957   1          VALVE1(0);
  958   1          VALVE2(0);
  959   1          VALVE3(0);
  960   1          VALVE4(0);
  961   1          VALVE5(0);
  962   1          VALVE6(0);
  963   1          VALVE7(0);
  964   1          Delay(20);
  965   1      }
  966          // 开启气泵
  967          void OpenPump()
  968          {
  969   1          //BUMP_M(1);
  970   1          g_Output[GAS_BUMP] = 1;
  971   1      }
  972          
  973          
  974          // 停止气泵
  975          void ClosePump()
  976          {
  977   1          //BUMP_M(0);
  978   1          CloseValve();
  979   1          g_Output[GAS_BUMP] = 0;
  980   1      }
  981          
  982          void SendReadFlowCmd(BYTE ch)
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 16  

  983          {
  984   1          ChannelError[ch-1] ++;
  985   1          SendReadFlow(ch);    
  986   1      }
  987          
  988          WORD GetAlarm(BYTE i)
  989          {
  990   1          //BYTE i;
  991   1      
  992   1      //    for (i=0;i<8;i++)
  993   1      //    {
  994   1              if(ChannelAlarm[i] == ALM_CH_DISABLE)
  995   1              {
  996   2                  return ALM_CH_DISABLE;
  997   2              }
  998   1              if (ChannelAlarm[i] ==  ALM_FLOW_ABNOR)
  999   1              {
 1000   2                  return ALM_FLOW_ABNOR;
 1001   2              }
 1002   1              
 1003   1              if (ChannelAlarm[i] ==  ALM_FLOW_HIGH)
 1004   1              {
 1005   2                  return ALM_FLOW_HIGH;
 1006   2              }
 1007   1      
 1008   1              if (ChannelAlarm[i] ==  ALM_FLOW_LOW)
 1009   1              {
 1010   2                  return ALM_FLOW_LOW;
 1011   2              }
 1012   1          //}
 1013   1      
 1014   1          return ALM_FLOW_NOR;
 1015   1      }
 1016          
 1017          void SyncModBusDev()
 1018          {
 1019   1          BYTE i;
 1020   1          memset(&ModBusParam, 0, sizeof(MODBUS_PARAM));
 1021   1          //ModBusParam.AlamrThres = SysParam.AlarmThres;
 1022   1          ModBusParam.ChEnable =  SysParam.Enable;
 1023   1      
 1024   1      //    for (i=0;i<8;i++)
 1025   1      //    {
 1026   1      //        ModBusParam.ChFlow[i] = (WORD)(SysParam.SampFlow[i]);
 1027   1      //        //ModBusParam.ChValve[i] = SysParam.Valve[i];
 1028   1      //    }
 1029   1      //    ModBusParam.SampFlow = SysParam.SampVol;
 1030   1      //    ModBusParam.SampMode = SysParam.SampMode;
 1031   1      //    ModBusParam.SampTime = SysParam.SampTime;
 1032   1      //    ModBusParam.SampVol = SysParam.SampVol;
 1033   1          ModBusParam.RemCtlFlag = SysParam.RemCtlFlag;
 1034   1          ModBusParam.Addr = RemRegAddr.SypAddr;
 1035   1          memset(&ModBusStatus, 0, sizeof(MODBUS_STATUS));
 1036   1      //    ModBusStatus.TotleTime = SysParam.TotleTime;
 1037   1      //    ModBusStatus.TotleVol = SysParam.TotleFlow;
 1038   1      
 1039   1      //    ModBusStatus.SampleFlow = RunStatus.TotleFlow;
 1040   1      //    ModBusStatus.SampleVol = RunStatus.TotleVol;
 1041   1          for(i = 0;i < 8;i++)
 1042   1          {
 1043   2              ModBusStatus.Alarm[i] = GetAlarm(i);
 1044   2          }
 1045   1      
 1046   1      //    ModBusStatus.RemTime = ((DWORD)SysParam.SampTime) * 60 - RunStatus.RunTime;
 1047   1      //    ModBusStatus.RunTime = RunStatus.RunTime;
 1048   1          ModBusStatus.RunStatus = RunStatus.Running;
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 17  

 1049   1          ModBusStatus.Addr = RemRegAddr.StuAddr;
 1050   1      //    for (i=0;i<8;i++)
 1051   1      //    {
 1052   1      //        ModBusStatus.ChFlow[i] = (WORD)(RunStatus.Flow[i]);
 1053   1      //        ModBusStatus.ChVol[i] = (WORD)(RunStatus.Volume[i]);
 1054   1      //    }
 1055   1      
 1056   1          memset(&ModBusInfo, 0, sizeof(MODBUS_INFO));
 1057   1          ModBusInfo.Address = 2;//SysParam.Address;
 1058   1          ModBusInfo.Version = VERSION;
 1059   1          ModBusInfo.Addr = RemRegAddr.InfoAddr;
 1060   1          
 1061   1      }
 1062          
 1063          //远程控制读写命令处理
 1064          BYTE SendRemCtlCmd(BYTE Addr, BYTE Cmd, WORD Reg, WORD Count, BYTE * Data)
 1065          {
 1066   1         
 1067   1          WORD i = 0;
 1068   1          WORD crc, SendLen;
 1069   1      
 1070   1          memset(&HostSendFrame, 0, sizeof(HOST_SEND_FRAME));
 1071   1          
 1072   1          HostSendFrame.Address = Addr; 
 1073   1          HostSendFrame.FunctionCode = Cmd;
 1074   1          HostSendFrame.RegAddr = RegSw(Reg);
 1075   1          HostSendFrame.RegCount =  RegSw(Count);
 1076   1      
 1077   1          SendLen = 6;
 1078   1      
 1079   1          if (((Count*2) > 0) && (Data != NULL))
 1080   1          {
 1081   2              //Remflag_RW = 0;
 1082   2              HostSendFrame.Data[0] = Count*2;  // 数据长度
 1083   2              SendLen ++;
 1084   2              i++;
 1085   2              memcpy(&HostSendFrame.Data[1], Data,Count*2);
 1086   2              SendLen += Count*2;
 1087   2              i+=(Count*2);
 1088   2              // 计算CRC , 并添加到数据后面
 1089   2      //        crc = CRC16Calc((BYTE *)&HostSendFrame, SendLen);
 1090   2      //        HostSendFrame.Data[i]  = (BYTE)(crc);
 1091   2      //        HostSendFrame.Data[i+1] = (BYTE)(crc>>8);
 1092   2      //        
 1093   2      //        SendLen += 2; 
 1094   2      //
 1095   2      //
 1096   2      //        Uart4Send((BYTE *)&HostSendFrame, (BYTE)SendLen);
 1097   2      //
 1098   2      //        return true;
 1099   2          }
 1100   1          //else
 1101   1          //{
 1102   1              //Remflag_RW = 1;
 1103   1              // 计算CRC , 并添加到数据后面
 1104   1              crc = CRC16Calc((BYTE *)&HostSendFrame, SendLen);
 1105   1              HostSendFrame.Data[i]  = (BYTE)(crc);
 1106   1              HostSendFrame.Data[i+1] = (BYTE)(crc>>8);
 1107   1              
 1108   1              SendLen += 2; 
 1109   1      
 1110   1      
 1111   1              Uart4Send((BYTE *)&HostSendFrame, (BYTE)SendLen);
 1112   1      
 1113   1              return true;
 1114   1          //}
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 18  

 1115   1      }
 1116          
 1117          void FlowTask()
 1118          {
 1119   1          if (RunStatus.Running)
 1120   1          {
 1121   2              if(SendFlowFlag == 1)
 1122   2              {
 1123   3                  SendFlowFlag = 0;
 1124   3                  SendReadFlowCmd(ChNum++);
 1125   3              }
 1126   2              
 1127   2              if (ChNum>9)
 1128   2              {
 1129   3                  ChNum = 1;
 1130   3              }
 1131   2          }
 1132   1      }
 1133          
 1134          //远程控制界面切换
 1135          void RemPageCtl()
 1136          {
 1137   1         //static BYTE StartRem[5] = {0};
 1138   1         //static BYTE RemFlag[5] = {0};
 1139   1      
 1140   1          switch(PageSwitch)
 1141   1          {
 1142   2              case 0:
 1143   2              {
 1144   3                  if(RunStatus.Running)
 1145   3                  {
 1146   4                      if(SysParam.RemCtlFlag)
 1147   4                      {
 1148   5                          if(!RemFlag[4])
 1149   5                          {
 1150   6                              RemFlag[4] = 1;
 1151   6                              StartRem[4]++;
 1152   6                              EnterPage(PAGE_REM);
 1153   6                             
 1154   6                          }
 1155   5                      }
 1156   4                      else
 1157   4                      {
 1158   5                          if(StartRem[4] != 0)
 1159   5                          {
 1160   6                              RemFlag[4]  = 0; 
 1161   6                              SendParam();
 1162   6                              ModeHint(); 
 1163   6                              CheckAlarm();
 1164   6                              EnterPage(PAGE_MAIN);
 1165   6                              StartRem[4] = 0;
 1166   6                          }
 1167   5                      }
 1168   4                  }
 1169   3                  else
 1170   3                  {
 1171   4                       if(SysParam.RemCtlFlag)
 1172   4                      {
 1173   5                          if(!RemFlag[0])
 1174   5                          {
 1175   6                              RemFlag[0] = 1;
 1176   6                              StartRem[0]++;
 1177   6                              EnterPage(PAGE_REM);
 1178   6                             
 1179   6                          }
 1180   5                      }
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 19  

 1181   4                      else
 1182   4                      {
 1183   5                          if(StartRem[0] != 0)
 1184   5                          {
 1185   6                              RemFlag[0]  = 0; 
 1186   6                              SendParam();
 1187   6                              ModeHint(); 
 1188   6                              EnterPage(PAGE_START);
 1189   6                              StartRem[0] = 0;
 1190   6                          }
 1191   5                      }
 1192   4                      break;
 1193   4                  }
 1194   3              }
 1195   2              
 1196   2              case 1:
 1197   2              {
 1198   3                  if(SysParam.RemCtlFlag)
 1199   3                  {
 1200   4                       if(!RemFlag[1])
 1201   4                      {
 1202   5                          RemFlag[1] = 1;
 1203   5                          StartRem[1]++;
 1204   5                          EnterPage(PAGE_REM);
 1205   5                          
 1206   5                       }
 1207   4                  }
 1208   3                  else
 1209   3                  {
 1210   4                       if(StartRem[1] != 0)
 1211   4                      {
 1212   5                          
 1213   5                          RemFlag[1] = 0;
 1214   5                          if(RunStatus.Running)
 1215   5                          {
 1216   6                              SendParam();
 1217   6                              ModeHint(); 
 1218   6                              CheckAlarm();
 1219   6                              EnterPage(PAGE_MAIN);
 1220   6                          }
 1221   5                          else
 1222   5                          {
 1223   6                              SendParam();
 1224   6                              ModeHint(); 
 1225   6                              UpdataUI();
 1226   6                              EnterPage(PAGE_MAIN);
 1227   6                          }
 1228   5                          StartRem[1] = 0;
 1229   5                       }
 1230   4                  }
 1231   3                  break;
 1232   3              }
 1233   2              
 1234   2               case 2:
 1235   2              {
 1236   3                  if(SysParam.RemCtlFlag)
 1237   3                  {
 1238   4                       if(!RemFlag[2])
 1239   4                      {
 1240   5                          RemFlag[2] = 1;
 1241   5                          StartRem[2]++;
 1242   5                          EnterPage(PAGE_REM);
 1243   5                         
 1244   5                       }
 1245   4                  }
 1246   3                  else
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 20  

 1247   3                  {
 1248   4                       if(StartRem[2] != 0)
 1249   4                      {
 1250   5                          RemFlag[2] = 0;
 1251   5                          SendParam();
 1252   5                          ModeHint(); 
 1253   5                          EnterPage(PAGE_SET);
 1254   5                          StartRem[2] = 0;
 1255   5                       }
 1256   4                  }
 1257   3                  break;
 1258   3              }
 1259   2               
 1260   2               case 3:
 1261   2              {
 1262   3                  if(SysParam.RemCtlFlag)
 1263   3                  {
 1264   4                       if(!RemFlag[3])
 1265   4                      {
 1266   5                          RemFlag[3] = 1;
 1267   5                          StartRem[3]++;
 1268   5                          EnterPage(PAGE_REM);
 1269   5                          
 1270   5                       }
 1271   4                  }
 1272   3                  else
 1273   3                  {
 1274   4                       if(StartRem[3] != 0)
 1275   4                      {
 1276   5                          RemFlag[3] = 0;
 1277   5                          SendParam();
 1278   5                          ModeHint(); 
 1279   5                          EnterPage(PAGE_TIME);
 1280   5                          StartRem[3] = 0;
 1281   5                       }
 1282   4                  }
 1283   3                 break; 
 1284   3              }  
 1285   2          }
 1286   1      }
 1287          
 1288          //远程控制向从机写
 1289          void RemCtlWrite()
 1290          {
 1291   1          WORD RegCnt = 3;
 1292   1          WORD RegCnt2 = 10;
 1293   1          SyncModBusDev();
 1294   1          
 1295   1          SendRemCtlCmd(2, CMD_WRITE_REG, MODBUS_PARAM_ADD, RegCnt, (BYTE *)&ModBusParam);
 1296   1          SendRemCtlCmd(2, CMD_WRITE_REG, MODBUS_STATUS_ADD, RegCnt2, (BYTE *)&ModBusStatus);
 1297   1          SendRemCtlCmd(2, CMD_WRITE_REG, MODBUS_INFO_ADD, RegCnt, (BYTE *)&ModBusInfo);
 1298   1      
 1299   1      }
 1300          
 1301          
 1302          //远程控制读从机
 1303          void RemCtlTask()
 1304          {   
 1305   1              WORD RegCnt = 3;
 1306   1          WORD RegCnt2 = 10;
 1307   1              //RemCtlWrite();
 1308   1          //Delay(200);
 1309   1      //    if (RunStatus.Running)
 1310   1      //    {
 1311   1               if(RemReadflag == 1)
 1312   1              {
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 21  

 1313   2                  RemReadflag = 0;
 1314   2      
 1315   2                  SendRemCtlCmd(2, CMD_READ_REG, MODBUS_PARAM_ADD, RegCnt, NULL);
 1316   2                  Delay(200);
 1317   2                  SendRemCtlCmd(2, CMD_READ_REG, MODBUS_STATUS_ADD, RegCnt2, NULL);  
 1318   2                  Delay(200);
 1319   2                  SendRemCtlCmd(2, CMD_READ_REG, MODBUS_INFO_ADD, RegCnt, NULL);
 1320   2                  Delay(200);
 1321   2      
 1322   2              }
 1323   1          //}
 1324   1          RemPageCtl();
 1325   1      }
 1326          
 1327          void main(void)
 1328          {
 1329   1          SysInit();
 1330   1          IoInit();
 1331   1          PW_MAIN(1);  // 主电源
 1332   1          LedInit();
 1333   1          
 1334   1          RUN_LED(1);
 1335   1         
 1336   1          Delay(200);
 1337   1          
 1338   1          Timer0Init();
 1339   1          Delay(200);
 1340   1          Adc_Init();
 1341   1          Delay(200);
 1342   1          
 1343   1          UART1_config();
 1344   1          UART2_config();
 1345   1          UART3_config();
 1346   1          UART4_config();
 1347   1          ClearUart1Buf();
 1348   1          ClearUart2Buf();
 1349   1          ClearUart3Buf();
 1350   1          ClearUart4Buf();
 1351   1          
 1352   1          // 待CPU稳定了再读参数
 1353   1          Delay(500);
 1354   1          ReadParam();
 1355   1          Delay(200);
 1356   1      
 1357   1          SyncModBusDev();
 1358   1          //RemCtlWrite();
 1359   1          
 1360   1          
 1361   1          RUN_LED(0);
 1362   1      
 1363   1          #if 0
                   while(1)
                   {
                       RUN_LED(0);
                       Delay(800);
                       RUN_LED(1);
                       Delay(200);
                   }
                   #endif
 1372   1          
 1373   1          
 1374   1          EA = 1;     //打开总中断
 1375   1      
 1376   1          WDT_CONTR |= (1<<5) |  7;  // 启动开门狗，约8秒
 1377   1      
 1378   1          Delay(200);
C251 COMPILER V5.60.0,  main                                                               24/10/23  15:04:21  PAGE 22  

 1379   1          InitLcd();
 1380   1          SysParam.RemCtlFlag = 0;
 1381   1          PageSwitch = 0;
 1382   1          while(1)
 1383   1          {
 1384   2              TimerTask();
 1385   2              HndInput();
 1386   2              FlowTask();
 1387   2              
 1388   2              Uart1Hnd();
 1389   2              Uart2Hnd();
 1390   2              Uart3Hnd();
 1391   2              
 1392   2        
 1393   2              //RemPageCtl(); 
 1394   2             //RemCtlWrite();
 1395   2              Uart4Hnd();
 1396   2              
 1397   2              RemCtlTask();
 1398   2          }
 1399   1      }
 1400          
 1401          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      5308     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       206     ------
  xdata-const size     =    ------     ------
  edata size           =       154     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       261     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
